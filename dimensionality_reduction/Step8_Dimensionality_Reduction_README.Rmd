---
title: "Step 8: Dimensionality Reduction"
output: 
  github_document
always_allow_html: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```

```{r}
github_dir <- "D:/Virtual_Machines/Shared_Folder/github/fMRI_FeaturesDisorders/"
source(paste0(github_dir, "helper_functions/Linear_SVM.R"))
source(paste0(github_dir, "helper_functions/Visualization.R"))
source(paste0(github_dir, "helper_functions/Null_distributions.R"))
rdata_path <- "D:/Virtual_Machines/Shared_Folder/PhD_work/data/scz/UCLA/Rdata/"
library(penalizedSVM)
library(factoextra)
library(FactoMineR)

noise_proc = "AROMA+2P"
noise_label = "AROMA_2P"

# Load catch22 data for current noise processing method
catch22_feature_matrix <- readRDS(paste0(rdata_path, 
                                         sprintf("UCLA_%s_catch22_filtered_zscored.Rds", 
                                                             noise_label)))     

# catchaMouse16_feature_matrix <- readRDS(paste0(rdata_path,
#                                                sprintf("UCLA_%s_catchaMouse16_zscored_filtered.Rds",
#                                                        noise_label)))
```


```{r}
# Load pyspi data
study <- "D:/Virtual_Machines/Shared_Folder/PhD_work/"
SPI_directionality <- read.csv("../6_Pairwise_ROI_analysis/SPI_Direction_Info.csv")
rdata_path_for_pyspi <- "D:/Virtual_Machines/Shared_Folder/PhD_work/data/scz/UCLA/pydata/R_files/"
all_pyspi_data <- readRDS(paste0(rdata_path_for_pyspi, "All_subject_pyspi.Rds"))
ROI_index <- read.csv(paste0(study, "data/scz/UCLA/pydata/ROI_info.csv"))
```

# ROI-wise
## catch22

### Run PCA

```{r}
ROI_PCA_list <- list()
ROI_PC_scores_list <- list()
ROI_eigen_list <- list()

for (brain_region in unique(feature_matrix$Brain_Region)) {
  ROI_data <- subset(ROI_matrix, Brain_Region == brain_region) %>%
    pivot_wider(id_cols = c(Subject_ID, group, Brain_Region),
                names_from = names,
                values_from = values) %>%
    drop_na()
  ROI_data_mat <- ROI_data %>%
    select(-Subject_ID, -group, -Brain_Region) %>%
    as.matrix()
  
  ROI_data_PCA <- prcomp(ROI_data_mat, center = TRUE, scale. = TRUE)
  ROI_PCA_list[[catch22_feature]] <- ROI_data_PCA
  
  ROI_PC_vals <- as.data.frame(ROI_data_PCA$x)
  ROI_PC_vals$group <- ROI_data$group
  ROI_PC_vals$feature <- catch22_feature
  ROI_PC_scores_list <- rlist::list.append(ROI_PC_scores_list, ROI_PC_vals)
  
  ROI_eigen  <- get_eig(ROI_data_PCA) %>%
    mutate(Components = 1:nrow(.)) %>%
    dplyr::rename("Percent_Variance" = "variance.percent",
                  "Cumulative_Variance" = "cumulative.variance.percent") %>%
    mutate(Brain_Region = brain_region)
  
  ROI_eigen_list <- rlist::list.append(ROI_eigen_list, ROI_eigen)
}

ROI_eigen_df <- do.call(plyr::rbind.fill, ROI_eigen_list)
ROI_PC_scores <- do.call(plyr::rbind.fill, ROI_PC_scores_list)

```

Cumulative variance plot:
```{r}
ROI_eigen_df %>%
  ggplot(data = ., mapping = aes(x=Components, y=Cumulative_Variance)) +
  geom_point() +
  geom_line(aes(group = Brain_Region), alpha = 0.5) +
  ylab("Cumulative Variance by ROI") +
  xlab("Number of PCs") +
  ggtitle("Region-wise PCA Cumulative Variance") +
  theme(plot.title = element_text(hjust = 0.5))
ggsave("plots/Region_Wise_PCA_Cumulative_Variance.png", width=6, height=4, 
       units="in", dpi=300)
```

### SVM with PCs: C = 1

#### Unweighted
```{r}
if (!file.exists(paste0(rdata_path, "ROI_wise_PCA_linear_SVM_unweighted.Rds"))) {
  ROI_wise_unweighted_SVM_by_PC_list <- list()
  
  # Iterate over each ROI
  for (this_ROI in unique(feature_matrix$Brain_Region)) {
    
    # Subset feature data from overall PCA results
    groups <- ROI_PC_scores %>%
      filter(Brain_Region == this_ROI) %>%
      pull(group)
    
    # Run SVM for current feature
    df_res <- run_SVM_from_PCA(
      PCA_res = ROI_PCA_list[[this_ROI]],
      group_vector = groups,
      c_values = c(1),
      interval = 2,
      use_inv_prob_weighting = FALSE,
      use_SMOTE = FALSE
    ) %>%
      mutate(Brain_Region = this_ROI)
    
    # Append this feature's linear SVM results to list
    ROI_wise_unweighted_SVM_by_PC_list <- rlist::list.append(ROI_wise_unweighted_SVM_by_PC_list,
                                                            df_res)
  }
  # Combine SVM results across features
  ROI_wise_PCA_linear_SVM_unweighted <- do.call(plyr::rbind.fill, ROI_wise_unweighted_SVM_by_PC_list)
  
  saveRDS(ROI_wise_PCA_linear_SVM_unweighted, paste0(rdata_path, "ROI_wise_PCA_linear_SVM_unweighted.Rds"))
} else {
  ROI_wise_PCA_linear_SVM_unweighted <- readRDS(paste0(rdata_path, "ROI_wise_PCA_linear_SVM_unweighted.Rds"))
}
```

#### Inverse probability weighted

```{r}
if (!file.exists(paste0(rdata_path, "ROI_wise_PCA_linear_SVM_inv_prob.Rds"))) {
  ROI_wise_SVM_inv_prob_by_PC_list <- list()
  
  # Iterate over each catch22 feature
  for (this_ROI in unique(feature_matrix$Brain_Region)) {
    
    # Subset feature data from overall PCA results
    groups <- ROI_PC_scores %>%
      filter(Brain_Region == this_ROI) %>%
      pull(group)
    
    # Run SVM for current feature
    df_res <- run_SVM_from_PCA(
      PCA_res = ROI_PCA_list[[this_ROI]],
      group_vector = groups,
      c_values = c(1),
      interval = 2,
      use_inv_prob_weighting = TRUE,
      use_SMOTE = FALSE
    ) %>%
      mutate(Brain_Region = this_ROI)
    
    # Append this feature's linear SVM results to list
    ROI_wise_SVM_inv_prob_by_PC_list <- rlist::list.append(ROI_wise_SVM_inv_prob_by_PC_list,
                                                                         df_res)
  }

  # Combine SVM results across features
  ROI_wise_PCA_linear_SVM_inv_prob <- do.call(plyr::rbind.fill, ROI_wise_SVM_inv_prob_by_PC_list)
  saveRDS(ROI_wise_PCA_linear_SVM_inv_prob, paste0(rdata_path, "ROI_wise_PCA_linear_SVM_inv_prob.Rds"))
} else {
  ROI_wise_PCA_linear_SVM_inv_prob <- readRDS(paste0(rdata_path, "ROI_wise_PCA_linear_SVM_inv_prob.Rds"))
}
```

#### All methods into one plot
```{r}
ROI_wise_PCA_linear_SVM_unweighted <- ROI_wise_PCA_linear_SVM_unweighted %>%
  mutate(Method = paste0(Sample_Type, ", unweighted"))
ROI_wise_PCA_linear_SVM_inv_prob <- ROI_wise_PCA_linear_SVM_inv_prob %>%
  mutate(Method = paste0(Sample_Type, ", inv prob"))

mega_df <- do.call(plyr::rbind.fill, list(ROI_wise_PCA_linear_SVM_unweighted,
                                          ROI_wise_PCA_linear_SVM_inv_prob))

# With smoothing
mega_df %>%
  mutate(Method = factor(Method, levels = unique(Method)),
         Unique_ID = paste0(Method, "_", Brain_Region)) %>%
  ggplot(data=., mapping = aes(x = Num_PCs, y = balanced_accuracy)) +
  geom_line(aes(group = Unique_ID), color="gray70", alpha=0.2) +
  stat_smooth(geom = "line", aes(group = Method, color = Method), size=1.5) +
  ggtitle("Balanced Accuracy for Brain Region-Wise\nLinear SVM by # PCs (Smoothed)") +
  ylab("Balanced Accuracy") +
  xlab("Number of PCs") +
  labs(color = "Classification\nMethod") +
  theme(plot.title = element_text(hjust=0.5))
ggsave("plots/ROI_Wise_PCA_All_Methods_Linear_SVM_Balanced_Accuracy.png", width=7, height=4, 
       units="in", dpi=300)
```


### SVM with PCs: evaluating different values of C

#### Unweighted

```{r}
if (!file.exists(paste0(rdata_path, "ROI_wise_PCA_linear_SVM_unweighted_diffC.Rds"))) {
  ROI_wise_unweighted_SVM_by_PC_list <- list()
  
  # Iterate over each catch22 feature
  for (this_ROI in unique(feature_matrix$Brain_Region)) {
    
    # Subset feature data from overall PCA results
    groups <- ROI_PC_scores %>%
      filter(Brain_Region == this_ROI) %>%
      pull(group)
    
    # Run SVM for current feature
    df_res <- run_SVM_from_PCA(
      PCA_res = ROI_PCA_list[[this_ROI]],
      group_vector = groups,
      c_values = 2^c(-10, -6, -2, 0, 2),
      interval = 1,
      use_inv_prob_weighting = FALSE,
      use_SMOTE = FALSE,
      return_all_fold_metrics = FALSE) %>%
      mutate(Brain_Region = this_ROI)
    
    # Append this feature's linear SVM results to list
    ROI_wise_unweighted_SVM_by_PC_list <- rlist::list.append(ROI_wise_unweighted_SVM_by_PC_list,
                                                                         df_res)
  }
    # Combine SVM results across features
  ROI_wise_PCA_linear_SVM_unweighted_diffC <- do.call(plyr::rbind.fill, ROI_wise_unweighted_SVM_by_PC_list)
  
  saveRDS(ROI_wise_PCA_linear_SVM_unweighted_diffC, paste0(rdata_path, "ROI_wise_PCA_linear_SVM_unweighted_diffC.Rds"))
} else {
  ROI_wise_PCA_linear_SVM_unweighted_diffC <- readRDS(paste0(rdata_path, "ROI_wise_PCA_linear_SVM_unweighted_diffC.Rds"))
}
```

#### Inverse probability weighting

```{r}
if (!file.exists(paste0(rdata_path, "ROI_wise_PCA_linear_SVM_inv_prob_diffC.Rds"))) {
  ROI_wise_inv_prob_SVM_by_PC_list <- list()
  
  # Iterate over each catch22 feature
  for (this_ROI in unique(feature_matrix$Brain_Region)) {
    
    # Subset feature data from overall PCA results
    groups <- ROI_PC_scores %>%
      filter(Brain_Region == this_ROI) %>%
      pull(group)
    
    # Run SVM for current feature
    df_res <- run_SVM_from_PCA(
      PCA_res = ROI_PCA_list[[this_ROI]],
      group_vector = groups,
      c_values = 2^c(-10, -6, -2, 0, 2),
      interval = 1,
      use_inv_prob_weighting = FALSE,
      use_SMOTE = FALSE,
      return_all_fold_metrics = FALSE) %>%
      mutate(Brain_Region = this_ROI)
    
    # Append this feature's linear SVM results to list
    ROI_wise_inv_prob_SVM_by_PC_list <- rlist::list.append(ROI_wise_inv_prob_SVM_by_PC_list,
                                                                         df_res)
  }
    # Combine SVM results across features
  ROI_wise_PCA_linear_SVM_inv_prob_diffC <- do.call(plyr::rbind.fill, ROI_wise_inv_prob_SVM_by_PC_list)
  
  saveRDS(ROI_wise_PCA_linear_SVM_inv_prob_diffC, paste0(rdata_path, "ROI_wise_PCA_linear_SVM_inv_prob_diffC.Rds"))
} else {
  ROI_wise_PCA_linear_SVM_inv_prob_diffC <- readRDS(paste0(rdata_path, "ROI_wise_PCA_linear_SVM_inv_prob_diffC.Rds"))
}
```

#### All methods into one plot
```{r}
ROI_wise_PCA_linear_SVM_unweighted_diffC <- ROI_wise_PCA_linear_SVM_unweighted_diffC %>%
  mutate(Method = paste0(Sample_Type, ", unweighted"))
ROI_wise_PCA_linear_SVM_inv_prob_diffC <- ROI_wise_PCA_linear_SVM_inv_prob_diffC %>%
  mutate(Method = paste0(Sample_Type, ", inv prob"))

mega_df <- do.call(plyr::rbind.fill, list(ROI_wise_PCA_linear_SVM_unweighted_diffC,
                                          ROI_wise_PCA_linear_SVM_inv_prob_diffC))

# With smoothing
mega_df %>%
  mutate(Method = factor(Method, levels = unique(Method)),
         Unique_ID = paste0(Method, "_", Brain_Region)) %>%
  ggplot(data=., mapping = aes(x = Num_PCs, y = balanced_accuracy)) +
  geom_line(aes(group = Unique_ID), color="gray70", alpha=0.2) +
  stat_smooth(geom = "line", aes(group = Method, color = Method), size=1.5) +
  facet_wrap(c_value ~ ., scales="free") +
  ggtitle("Balanced Accuracy for Brain-Region Wise\nLinear SVM by # PCs and C Value") +
  ylab("Balanced Accuracy") +
  xlab("Number of PCs") +
  labs(color = "Classification\nMethod") +
  theme(plot.title = element_text(hjust=0.5),
        legend.position = "bottom") +
  guides(color = guide_legend(nrow=2,byrow=TRUE))
ggsave("plots/ROI_Wise_PCA_All_Methods_Linear_SVM_Balanced_Accuracy_diffC.png", width=7, height=6, 
       units="in", dpi=300)
```




# Feature-wise

### Run PCA
```{r}
feature_PCA_list <- list()
feature_PC_scores_list <- list()
feature_eigen_list <- list()

for (catch22_feature in unique(feature_matrix$names)) {
  feature_data <- subset(feature_matrix, names == catch22_feature) %>%
    pivot_wider(id_cols = c(Subject_ID, group, names),
                names_from = Brain_Region,
                values_from = values) %>%
    drop_na()
  feature_data_mat <- feature_data %>%
    select(-Subject_ID, -group, -names) %>%
    as.matrix()
  
  feature_data_PCA <- prcomp(feature_data_mat, center = TRUE, scale. = TRUE)
  feature_PCA_list[[catch22_feature]] <- feature_data_PCA
  
  feature_PC_vals <- as.data.frame(feature_data_PCA$x)
  feature_PC_vals$group <- feature_data$group
  feature_PC_vals$feature <- catch22_feature
  feature_PC_scores_list <- rlist::list.append(feature_PC_scores_list, feature_PC_vals)
  
  feature_eigen  <- get_eig(feature_data_PCA) %>%
    mutate(Components = 1:nrow(.)) %>%
    dplyr::rename("Percent_Variance" = "variance.percent",
                  "Cumulative_Variance" = "cumulative.variance.percent") %>%
    mutate(catch22_Feature = catch22_feature)
  
  feature_eigen_list <- rlist::list.append(feature_eigen_list, feature_eigen)
}

feature_eigen_df <- do.call(plyr::rbind.fill, feature_eigen_list)
feature_PC_scores <- do.call(plyr::rbind.fill, feature_PC_scores_list)
```

```{r}
feature_eigen_df %>%
  ggplot(data = ., mapping = aes(x=Components, y=Cumulative_Variance)) +
  geom_point() +
  geom_line(aes(group = catch22_Feature), alpha = 0.5) +
  ylab("Cumulative Variance by Feature") +
  xlab("Number of PCs") +
  ggtitle("catch22 Feature-wise PCA Cumulative Variance") +
  theme(plot.title = element_text(hjust = 0.5))
ggsave("plots/Feature_Wise_PCA_Cumulative_Variance.png", width=6, height=4, 
       units="in", dpi=300)
```

### SVM with PCs: C = 1

#### Unweighted
```{r}
if (!file.exists(paste0(rdata_path, "Feature_wise_PCA_linear_SVM_unweighted_catch22.Rds"))) {
  Feature_wise_unweighted_SVM_by_PC_list <- list()
  
  # Iterate over each catch22 feature
  for (this_feature in unique(feature_matrix$names)) {
    
    # Subset feature data from overall PCA results
    groups <- feature_PC_scores %>%
      filter(feature == this_feature) %>%
      pull(group)
    
    # Run SVM for current feature
    df_res <- run_SVM_from_PCA(
      PCA_res = feature_PCA_list[[this_feature]],
      group_vector = groups,
      c_values = 1,
      interval = 2,
      use_inv_prob_weighting = FALSE,
      use_SMOTE = FALSE,
      return_all_fold_metrics = FALSE) %>%
      mutate(catch22_feature = this_feature)
    
    # Append this feature's linear SVM results to list
    Feature_wise_unweighted_SVM_by_PC_list <- rlist::list.append(Feature_wise_unweighted_SVM_by_PC_list,
                                                                         df_res)
  }
    # Combine SVM results across features
  Feature_wise_PCA_linear_SVM_unweighted <- do.call(plyr::rbind.fill, Feature_wise_unweighted_SVM_by_PC_list)
  
  saveRDS(Feature_wise_PCA_linear_SVM_unweighted, paste0(rdata_path, "Feature_wise_PCA_linear_SVM_unweighted_catch22.Rds"))
} else {
  Feature_wise_PCA_linear_SVM_unweighted <- readRDS(paste0(rdata_path, "Feature_wise_PCA_linear_SVM_unweighted_catch22.Rds"))
}
```
#### Inverse probability weighted

```{r}
if (!file.exists(paste0(rdata_path, "Feature_wise_PCA_linear_SVM_inv_prob_catch22.Rds"))) {
  Feature_wise_SVM_inv_prob_by_PC_list <- list()
  
  # Iterate over each catch22 feature
  for (this_feature in unique(feature_matrix$names)) {
    
    # Subset feature data from overall PCA results
    groups <- feature_PC_scores %>%
      filter(feature == this_feature) %>%
      pull(group)
    
    # Run SVM for current feature
    df_res <- run_SVM_from_PCA(
      PCA_res = feature_PCA_list[[this_feature]],
      group_vector = groups,
      c_values = 1,
      interval = 2,
      use_inv_prob_weighting = TRUE,
      use_SMOTE = FALSE
    ) %>%
      mutate(catch22_feature = this_feature)
    
    # Append this feature's linear SVM results to list
    Feature_wise_SVM_inv_prob_by_PC_list <- rlist::list.append(Feature_wise_SVM_inv_prob_by_PC_list,
                                                                         df_res)
  }

  # Combine SVM results across features
  Feature_wise_PCA_linear_SVM_inv_prob <- do.call(plyr::rbind.fill, Feature_wise_SVM_inv_prob_by_PC_list)
  saveRDS(Feature_wise_PCA_linear_SVM_inv_prob, paste0(rdata_path, "Feature_wise_PCA_linear_SVM_inv_prob_catch22.Rds"))
} else {
  Feature_wise_PCA_linear_SVM_inv_prob <- readRDS(paste0(rdata_path, "Feature_wise_PCA_linear_SVM_inv_prob_catch22.Rds"))
}
```

#### All methods into one plot
```{r}
Feature_wise_PCA_linear_SVM_unweighted <- Feature_wise_PCA_linear_SVM_unweighted %>%
  mutate(Method = paste0(Sample_Type, ", unweighted"))
Feature_wise_PCA_linear_SVM_inv_prob <- Feature_wise_PCA_linear_SVM_inv_prob %>%
  mutate(Method = paste0(Sample_Type, ", inv prob"))

mega_df <- do.call(plyr::rbind.fill, list(Feature_wise_PCA_linear_SVM_unweighted,
                                          Feature_wise_PCA_linear_SVM_inv_prob))

# With smoothing
mega_df %>%
  mutate(Method = factor(Method, levels = unique(Method)),
         Unique_ID = paste0(Method, "_", catch22_feature)) %>%
  ggplot(data=., mapping = aes(x = Num_PCs, y = balanced_accuracy)) +
  geom_line(aes(group = Unique_ID), color="gray70", alpha=0.2) +
  stat_smooth(geom = "line", aes(group = Method, color = Method), size=1.5) +
  ggtitle("Balanced Accuracy for catch22 Feature-Wise\nLinear SVM by # PCs (Smoothed)") +
  ylab("Balanced Accuracy") +
  xlab("Number of PCs") +
  labs(color = "Classification\nMethod") +
  theme(plot.title = element_text(hjust=0.5))
ggsave("plots/Feature_Wise_PCA_All_Methods_Linear_SVM_Balanced_Accuracy.png", width=7, height=4, 
       units="in", dpi=300)
```


# Combo-wise

### Run PCA

```{r}
combo_data <- catch22_feature_matrix %>%
  tidyr::unite("Combo", Brain_Region, names, sep="_") %>%
  pivot_wider(id_cols = c(Subject_ID, group),
              names_from = Combo,
              values_from = values) %>%
  drop_na() 
combo_data_mat <- combo_data %>%
  dplyr::select(-Subject_ID, -group) %>%
  as.matrix()

combo_data_PCA <- prcomp(combo_data_mat, center = TRUE, scale. = TRUE)

combo_eigen  <- get_eig(combo_data_PCA) %>%
  mutate(Components = 1:nrow(.)) %>%
  dplyr::rename("Percent_Variance" = "variance.percent",
                "Cumulative_Variance" = "cumulative.variance.percent")

combo_PC_vals <- as.data.frame(combo_data_PCA$x)
combo_PC_vals$group <- combo_data$group
```


Cumulative variance

```{r}
combo_eigen %>%
  ggplot(data = ., mapping = aes(x=Components, y=Cumulative_Variance)) +
  geom_point() +
  geom_line() +
  ylab("Cumulative Variance") +
  xlab("Number of PCs") +
  ggtitle("Combo-wise PCA Cumulative Variance") +
  theme(plot.title = element_text(hjust = 0.5))
ggsave("plots/Combo_Wise_PCA_Cumulative_Variance.png", width=6, height=4, 
       units="in", dpi=300)
```

### SVM with PCs: C = 1

#### Unweighted
```{r}
# Run in-sample linear SVM for each number of PCs from 1 to 167
if (!file.exists(paste0(rdata_path, "Combo_wise_PCA_CV_linear_SVM_unweighted_catch22.Rds"))) {
  Combo_wise_PCA_linear_SVM_unweighted <- run_SVM_from_PCA(
    PCA_res = combo_data_PCA,
    group_vector = combo_data$group,
    interval = 2,
    c_values = 1,
    use_inv_prob_weighting = FALSE,
    use_SMOTE = FALSE
  )
  saveRDS(Combo_wise_PCA_linear_SVM_unweighted, paste0(rdata_path, "Combo_wise_PCA_CV_linear_SVM_unweighted_catch22.Rds"))
} else {
  Combo_wise_PCA_linear_SVM_unweighted <- readRDS(paste0(rdata_path, "Combo_wise_PCA_CV_linear_SVM_unweighted_catch22.Rds"))
}
```

#### Inverse probability weighted

```{r}
# Run in-sample linear SVM with inverse probability weighting for each number of PCs from 1-167
if (!file.exists(paste0(rdata_path, "Combo_wise_PCA_CV_linear_SVM_inv_prob_catch22.Rds"))) {
   
  Combo_wise_PCA_linear_SVM_inv_prob <- run_SVM_from_PCA(
    PCA_res = combo_data_PCA,
    group_vector = combo_data$group,
    interval = 2,
    c_values = 1,
    use_inv_prob_weighting = TRUE,
    use_SMOTE = FALSE
  )
  saveRDS(Combo_wise_PCA_linear_SVM_inv_prob, paste0(rdata_path, "Combo_wise_PCA_CV_linear_SVM_inv_prob_catch22.Rds"))
} else {
  Combo_wise_PCA_linear_SVM_inv_prob <- readRDS(paste0(rdata_path, "Combo_wise_PCA_CV_linear_SVM_inv_prob_catch22.Rds"))
}
```

#### All methods into one plot
```{r}
Combo_wise_PCA_linear_SVM_unweighted <- Combo_wise_PCA_linear_SVM_unweighted %>%
  mutate(Method = paste0(Sample_Type, ", unweighted"))
Combo_wise_PCA_linear_SVM_inv_prob <- Combo_wise_PCA_linear_SVM_inv_prob %>%
  mutate(Method = paste0(Sample_Type, ", inv prob"))

Combo_wise_PCA_res_combined <- do.call(plyr::rbind.fill, 
                                       list(Combo_wise_PCA_linear_SVM_unweighted,
                                            Combo_wise_PCA_linear_SVM_inv_prob))
```


```{r}
# With smoothing
Combo_wise_PCA_res_combined %>%
  mutate(Method = factor(Method, levels = unique(Method))) %>%
  ggplot(data=., mapping = aes(x = Num_PCs, y = balanced_accuracy)) +
  geom_line(aes(group = Method), color="gray70", alpha=0.2) +
  stat_smooth(geom = "line", aes(group = Method, color = Method), size=1.5) +
  ggtitle("Balanced Accuracy for ROI/Feature\nCombo-Wise Linear SVM by # PCs") +
  ylab("Balanced Accuracy") +
  xlab("Number of PCs") +
  labs(color = "Classification\nMethod") +
  theme(plot.title = element_text(hjust=0.5))
ggsave("plots/Combo_Wise_PCA_All_Methods_Linear_SVM_Balanced_Accuracy.png", width=7, height=4, 
       units="in", dpi=300)
```

#### Reducing number of PCs

Stop PCs when in-sample balanced accuracy reaches 1:
```{r}
total_num_pcs <- max(Combo_wise_PCA_res_combined$Num_PCs)
pcs_with_balanced_accuracy_1 <- Combo_wise_PCA_linear_SVM_inv_prob %>%
  filter(Sample_Type == "In-sample",
         balanced_accuracy == 1) %>%
  arrange(Num_PCs) %>%
  slice(1) %>%
  pull(Num_PCs)

Combo_wise_PCA_linear_SVM_inv_prob %>%
  filter(Sample_Type == "In-sample")
```

Stop PCs when there is an inflection point in the in-sample balanced accuracy:

```{r}
# Raw data
X <- Combo_wise_PCA_linear_SVM_inv_prob %>% 
  filter(Sample_Type=="In-sample") %>%
  pull(Num_PCs)
Y <- Combo_wise_PCA_linear_SVM_inv_prob %>% filter(Sample_Type == "In-sample") %>% pull(balanced_accuracy)

dY <- diff(Y)/diff(X)
X_for_dY <- X[-1]
dY2 <- diff(dY)/diff(X_for_dY)
X_for_dY2 <- X_for_dY[-1]

# Loess-smoothed data
in_sample_balanced_accuracy_loess <- loess(balanced_accuracy ~ Num_PCs,
                                           data = subset(Combo_wise_PCA_linear_SVM_inv_prob,
                                                         Sample_Type == "In-sample"),
                                           span = 0.75)

X <- Combo_wise_PCA_linear_SVM_inv_prob %>% 
  filter(Sample_Type=="In-sample") %>%
  pull(Num_PCs)
Y_loess <- in_sample_balanced_accuracy_loess$fitted

dY_loess <- diff(Y_loess)/diff(X)
X_for_dY_loess <- X[-1]
dY2_loess <- diff(dY_loess)/diff(X_for_dY)
X_for_dY2_loess <- X_for_dY_loess[-1]

data.frame(X = rep(c(X, X_for_dY, X_for_dY2), 2),
           Y = c(Y, dY, dY2, Y_loess, dY_loess, dY2_loess),
           method = rep(c(rep("Original", length(X)),
                      rep("First Deriv", length(dY)),
                      rep("Second Deriv", length(dY2))), 2),
           measure = c(rep("Raw", length(c(X, X_for_dY, X_for_dY2))),
                       rep("Loess", length(c(X, X_for_dY, X_for_dY2))))) %>%
  mutate(method = factor(method, levels = c("Original",
                                            "First Deriv",
                                            "Second Deriv")),
         measure = factor(measure, levels = c("Raw", "Loess"))) %>%
  mutate(chosen_num_PCs = unique(X[Y == min(dY2_loess, na.rm=T)])) %>%
  ggplot(data=., mapping = aes(x = X, y = Y)) +
  geom_line(aes(group = method, color = method)) +
  geom_vline(aes(xintercept = chosen_num_PCs)) +
  facet_wrap(method ~ measure, nrow = 2, scales = "free_y", dir = "v") +
  ggtitle("Combo-wise Univariate PCA: Finding\nInflection Point in In-Sample Balanced Accuracy") +
  theme(legend.position = "none",
        plot.title = element_text(hjust=0.5))
```


```{r}
in_sample_balanced_accuracy_loess <- loess(balanced_accuracy ~ Num_PCs,
                                           data = subset(Combo_wise_PCA_linear_SVM_inv_prob,
                                                         Sample_Type == "In-sample"),
                                           span = 0.75)





# Take first derivative
loess_dY <- diff(loess_Y)/diff(loess_X)  # the derivative of your function
loess_dX <- rowMeans(embed(loess_X,2)) # centers the X values for plotting

# Take second derivative
loess_dY2 <- diff(loess_dY)/diff(loess_dX)
loess_dX2 <- rowMeans(embed(loess_dX, 2))

# Plot loess along with first and second derivatives
inflection_point_x <- 69
p_loess <- ggplot(data = data.frame(x = loess_X,
                                    y = loess_Y),
                  mapping = aes(x = x, y = y)) +
  geom_point() +
  ggtitle("Loess Fit") +
  ylab("Loess Fitted Value") +
  xlab("Number of PCs") +
  geom_line() +
  geom_vline(xintercept = inflection_point_x, linetype = 2, color = "red") +
  theme(plot.title = element_text(hjust=0.5))

p_d1 <- ggplot(data = data.frame(x = loess_dX,
                                    y = loess_dY),
                  mapping = aes(x = x, y = y)) +
  geom_point() +
  ggtitle("First Derivative") +
  geom_vline(xintercept = 67, linetype = 2, color = "red") +
  ylab("dY") +
  xlab("dX") +
  geom_line() +
  theme(plot.title = element_text(hjust=0.5))

p_d2 <- data.frame(x = loess_dX2, y = loess_dY2) %>%
  mutate(min_y = y == min(y),
         min_y_label = ifelse(min_y, x, "")) %>%
  ggplot(data = ., mapping = aes(x = x, y = y)) +
  geom_line() +
  geom_point(aes(color = min_y)) + 
  geom_text(aes(label = min_y_label, color = min_y),
            hjust = -0.5) +
  scale_colour_manual(values = c("black", "red")) +
  ggtitle("Second Derivative") +
  ylab("ddY") +
  xlab("ddX") +
  theme(plot.title = element_text(hjust=0.5),
        legend.position = "none")

p_loess + p_d1 + p_d2 + plot_annotation(
  title = 'Loess Smoothing of PCs from Combo-wise catch22\nInverse Probability-Weighted Linear SVM') &
  theme(plot.title = element_text(hjust=0.5))
ggsave("plots/Combo_Univariate_Loess_Derivatives.png",
       width = 13, height = 5, units="in", dpi=300)
```


Compare results:
```{r}
# Compare results using PCs where balanced accuracy first hits 100%
# With the total number of PCs
Combo_wise_PCA_res_combined %>%
  filter(Num_PCs %in% c(total_num_pcs, 
                        pcs_with_balanced_accuracy_1,
                        inflection_point_x),
         Sample_Type == "Out-of-sample") %>%
  dplyr::select(Method, Num_PCs, balanced_accuracy, balanced_accuracy_SD) %>%
  mutate(PC_stop_point = case_when(Num_PCs == pcs_with_balanced_accuracy_1 ~ "First In-Sample Balanced Accuracy of 100%",
                                   Num_PCs == total_num_pcs ~ "Full set of PCs",
                                   Num_PCs == inflection_point_x ~ "Inflection Point of Loess Curve",
                                   T ~ "")) %>%
  mutate(PC_stop_point = factor(PC_stop_point, levels = c("Full set of PCs",
                                                          "First In-Sample Balanced Accuracy of 100%",
                                                          "Inflection Point of Loess Curve"))) %>%
  ggplot(data = ., mapping = aes(x = Method, y = balanced_accuracy,
                                 fill = PC_stop_point)) +
  geom_bar(stat = "identity",
           position = position_dodge()) +
  geom_errorbar(aes(ymin = balanced_accuracy - balanced_accuracy_SD,
                    ymax = balanced_accuracy + balanced_accuracy_SD,
                    group = PC_stop_point),
                position = position_dodge()) +
  ggtitle("Evaluating PC Stopping Points for catch22 CV Linear SVM") +
  ylab("Balanced Accuracy,\n10-fold Out-of-Sample") +
  xlab("Weighting Method") +
  labs(fill = "PC Stopping Point") +
  theme(legend.position = "bottom",
        plot.title = element_text(hjust=0.5)) +
  guides(fill=guide_legend(nrow=3,byrow=TRUE))
ggsave("plots/Combo_Univariate_PC_Stop_Point_OOS_Balanced_Accuracy.png",
       width = 7, height = 6, units="in", dpi=300)
```


### SVM with PCs: evaluating different values of C

#### Unweighted

```{r}
# Run unweighted linear SVM for each number of PCs from 1 to 167 by 2, 
# with different C-intervals
if (!file.exists(paste0(rdata_path, "Combo_wise_PCA_linear_SVM_unweighted_diffC.Rds"))) {
  Combo_wise_PCA_linear_SVM_unweighted_diffC <- run_SVM_from_PCA(
    PCA_res = combo_data_PCA,
    group_vector = combo_data$group,
    c_values = 2^c(-10, -6, -2, 0, 2),
    interval = 5,
    use_inv_prob_weighting = FALSE,
    use_SMOTE = FALSE
  )
  saveRDS(Combo_wise_PCA_linear_SVM_unweighted_diffC, paste0(rdata_path, "Combo_wise_PCA_linear_SVM_unweighted_diffC.Rds"))
} else {
  Combo_wise_PCA_linear_SVM_unweighted_diffC <- readRDS(paste0(rdata_path, "Combo_wise_PCA_linear_SVM_unweighted_diffC.Rds"))
}
```

#### Inverse probability weighting

```{r}
# Run unweighted linear SVM for each number of PCs from 1 to 167 by 2, 
# with different C-intervals
if (!file.exists(paste0(rdata_path, "Combo_wise_PCA_linear_SVM_inv_prob_diffC.Rds"))) {
  Combo_wise_PCA_linear_SVM_inv_prob_diffC <- run_SVM_from_PCA(
    PCA_res = combo_data_PCA,
    group_vector = combo_data$group,
    c_values = 2^c(-10, -6, -2, 0, 2),
    interval = 5,
    use_inv_prob_weighting = FALSE,
    use_SMOTE = FALSE
  )
  saveRDS(Combo_wise_PCA_linear_SVM_inv_prob_diffC, paste0(rdata_path, "Combo_wise_PCA_linear_SVM_inv_prob_diffC.Rds"))
} else {
  Combo_wise_PCA_linear_SVM_inv_prob_diffC <- readRDS(paste0(rdata_path, "Combo_wise_PCA_linear_SVM_inv_prob_diffC.Rds"))
}
```

#### All methods into one plot
```{r}
Combo_wise_PCA_linear_SVM_unweighted_diffC <- Combo_wise_PCA_linear_SVM_unweighted_diffC %>%
  mutate(Method = paste0(Sample_Type, ", unweighted"))
Combo_wise_PCA_linear_SVM_inv_prob_diffC <- Combo_wise_PCA_linear_SVM_inv_prob_diffC %>%
  mutate(Method = paste0(Sample_Type, ", inv prob"))

mega_df <- do.call(plyr::rbind.fill, list(Combo_wise_PCA_linear_SVM_unweighted_diffC,
                                          Combo_wise_PCA_linear_SVM_inv_prob_diffC))

# With smoothing
mega_df %>%
  mutate(Method = factor(Method, levels = unique(Method))) %>%
  ggplot(data=., mapping = aes(x = Num_PCs, y = balanced_accuracy)) +
  geom_line(aes(group = Method), color="gray70", alpha=0.2) +
  stat_smooth(geom = "line", aes(group = Method, color = Method), size=1.5) +
  facet_wrap(c_value ~ ., scales="free") +
  ggtitle("Balanced Accuracy for ROI/Feature\nCombo-Wise Linear SVM by # PCs") +
  ylab("Balanced Accuracy") +
  xlab("Number of PCs") +
  labs(color = "Classification\nMethod") +
  theme(plot.title = element_text(hjust=0.5),
        legend.position = "bottom") +
  guides(color = guide_legend(nrow=2,byrow=TRUE))
ggsave("plots/Combo_Wise_PCA_All_Methods_Linear_SVM_Balanced_Accuracy_diffC.png", width=7, height=6, 
       units="in", dpi=300)
```




## Regularization

### Exploring penalizedSVM

```{r}
example_ROI <- "ctx-lh-bankssts"
full_data_for_SVM <- catch22_feature_matrix %>%
  tidyr::unite("Unique_ID", c(names, Brain_Region), sep="_") %>%
  pivot_wider(id_cols = c(Subject_ID, group),
              names_from = Unique_ID,
              values_from = values) %>%
  dplyr::select(-Subject_ID) %>%
  mutate(group = ifelse(group == "Schz", 1, -1)) %>%
  as.matrix() 

# train data
model <- lpsvm(A=full_data_for_SVM[, -1], 
               d=full_data_for_SVM[,1], 
               k=5, 
               nu=0,
               output=0, 
               delta=10^-3, 
               epsi=0.001, 
               seed=127)

data.frame(terms = names(model$w),
           coeff = model$w) %>%
  mutate(terms = fct_reorder(terms, coeff)) %>%
  ggplot(data=., mapping=aes(x = terms, y = coeff)) +
  geom_bar(aes(fill = coeff), stat = "identity") +
  ggtitle("L1-Regularized catch22\nCombo-wise Linear SVM") +
  scale_fill_gradient2(low = "blue", mid = "gray70", high = "red") +
  ylab("Hyperplane Coefficients") +
  xlab("Combo-wise catch22 Terms") +
  coord_flip() +
  theme(legend.position = "none",
        plot.title = element_text(hjust=0.5))
ggsave("plots/L1_Regularized_Combo_Wise_catch22_Linear_SVM_coefficients.png",
       width=10, height = 6, units="in", dpi=300)
```

Correlation heatmap
```{r}
corrmap <- catch22_feature_matrix %>%
  tidyr::unite("Unique_ID", c("names", "Brain_Region"), sep="_") %>%
  pivot_wider(id_cols = "Subject_ID", names_from = Unique_ID, values_from = values) %>%
  dplyr::select(-Subject_ID) %>%
  cor(method = "pearson")

hclustmap <- hclust(dist(corrmap))
hclust_ordering <- hclustmap$labels[hclustmap$order]

as.data.frame(corrmap) %>%
  rownames_to_column(var = "Var1") %>%
  pivot_longer(cols = c(-Var1), names_to="Var2", 
               values_to = "corr") %>%
  mutate(Var1 = factor(Var1, levels = hclust_ordering),
         Var2 = factor(Var2, levels = hclust_ordering)) %>%
  ggplot(data=., mapping=aes(x=Var1, y=Var2, fill=corr)) +
  geom_tile() +
  ylab("")
  theme(axis.text = element_blank())

library(pheatmap)
pheatmap(corrmap, show_rownames = F, show_colnames = F)
```


# Pairwise (pyspi)

Run PCA by pySPI SPI
```{r}
pairwise_PCA_list <- list()
pairwise_PC_scores_list <- list()
pairwise_eigen_list <- list()
for (this_SPI in unique(all_pyspi_data$SPI)) {
  directionality <- SPI_directionality %>% filter(SPI == this_SPI) %>% pull(Direction)
  
  # Reshape SPI data to contain brain region names
  SPI_data <- subset(all_pyspi_data, SPI == this_SPI)  %>%
    mutate(comparison = row_number()) %>%
    pivot_longer(cols = c(brain_region_1,
                          brain_region_2),
                 names_to = "Region_Number",
                 values_to = "Index") %>%
    left_join(ROI_index) %>%
    dplyr::select(-Index) %>%
    pivot_wider(id_cols = c("Subject_ID", "group", "SPI", "value", "comparison"),
                names_from = "Region_Number",
                values_from = "ROI") %>%
    dplyr::select(-comparison) 
  
  # Combine brain regions into new pairwise column depending on directionality
  if (directionality == "Undirected") {
    SPI_data <- SPI_data %>%
      mutate(region_pair = ifelse(brain_region_1 < brain_region_2,
                                  paste0(brain_region_1, "_", brain_region_2),
                                  paste0(brain_region_2, "_", brain_region_1)))
  } else if (directionality == "Directed") {
    SPI_data <- SPI_data %>%
      mutate(region_pair = paste0(brain_region_1, "_", brain_region_2))
  }
  
  # Pivot data from long to wide for SVM
  data_for_PCA <- SPI_data %>%
    dplyr::select(Subject_ID, group, region_pair, value) %>%
    mutate(value = round(value, 8)) %>%
    distinct() %>%
    pivot_wider(id_cols = c(Subject_ID, group),
                names_from = region_pair, 
                values_from = value) %>%
    dplyr::select(-Subject_ID) %>%
    drop_na()
  
  pairwise_data_mat <- data_for_PCA %>%
    select(-group) %>%
    as.matrix()
  
  tryCatch({
    pairwise_data_PCA <- prcomp(pairwise_data_mat, center = TRUE, scale. = TRUE)
  
  pairwise_PC_vals <- as.data.frame(pairwise_data_PCA$x)
  pairwise_PC_vals$group <- data_for_PCA$group
  pairwise_PC_vals$SPI <- this_SPI
  
  pairwise_eigen  <- get_eig(pairwise_data_PCA) %>%
    mutate(Components = 1:nrow(.)) %>%
    dplyr::rename("Percent_Variance" = "variance.percent",
                  "Cumulative_Variance" = "cumulative.variance.percent") %>%
    mutate(SPI = this_SPI)
  
  # Append results to list
  pairwise_PCA_list[[this_SPI]] <- pairwise_data_PCA
  pairwise_PC_scores_list <- rlist::list.append(pairwise_PC_scores_list, pairwise_PC_vals)
  pairwise_eigen_list <- rlist::list.append(pairwise_eigen_list, pairwise_eigen)
  }, error = function(e) {
    cat("\nCould not run PCA for", this_SPI, "\n")
    print(e)
  })
  
}

pairwise_eigen_df <- do.call(plyr::rbind.fill, pairwise_eigen_list)
pairwise_PC_scores <- do.call(plyr::rbind.fill, pairwise_PC_scores_list)
```

Cumulative variance plot for SPIs:
```{r}
pairwise_eigen_df %>%
  mutate(SPI = fct_reorder(SPI, Cumulative_Variance, .fun = mean)) %>%
  ggplot(data = ., mapping = aes(x=Components, y=Cumulative_Variance, color = SPI)) +
  geom_point() +
  geom_line(aes(group = SPI, color = SPI), alpha = 0.5) +
  ylab("Cumulative Variance by Pairwise SPI") +
  xlab("Number of PCs") +
  ggtitle("pySPI Pairwise SPI PCA Cumulative Variance") +
  theme(plot.title = element_text(hjust = 0.5),
        legend.position = "bottom") +
  guides(color=guide_legend(nrow=10,byrow=TRUE))
ggsave("plots/Pairwise_SPI_PCA_Cumulative_Variance.png", width=10, height=6, 
       units="in", dpi=300)
```

Iterate through every PCs from 1 to # subjects to see to see at what point in-sample linear SVM reaches 100% accuracy per pyspi SPI:

```{r}
if (!file.exists(paste0(rdata_path, "Pairwise_PCA_linear_SVM_in_sample.Rds"))) {
  Pairwise_in_sample_SVM_by_PC_list <- list()
  
  # Iterate over each pyspi SPI
  for (this_SPI in unique(all_pyspi_data$SPI)) {
    
    # Subset SPI data from overall PCA results
    groups <- pairwise_PC_scores %>%
      filter(SPI == this_SPI) %>%
      mutate(group = stringr::str_to_title(group)) %>%
      pull(group)
    
    tryCatch({
      # Run SVM for current feature
      df_res <- run_SVM_from_PCA(
        PCA_res = pairwise_PCA_list[[this_SPI]],
        group_vector = groups,
        cross_validate = FALSE,
        use_inv_prob_weighting = FALSE,
        use_SMOTE = FALSE
      ) %>%
        mutate(SPI = this_SPI)
      
      # Append this feature's linear SVM results to list
      Pairwise_in_sample_SVM_by_PC_list <- rlist::list.append(Pairwise_in_sample_SVM_by_PC_list,
                                                              df_res)
    }, error = function(e) {
      cat("\nCould not run SVM for", this_SPI, "\n")
      print(e)
    })
    
  }
    # Combine SVM results across features
  Pairwise_PCA_linear_SVM_in_sample <- do.call(plyr::rbind.fill, Pairwise_in_sample_SVM_by_PC_list)
  
  saveRDS(Pairwise_PCA_linear_SVM_in_sample, paste0(rdata_path, "Pairwise_PCA_linear_SVM_in_sample.Rds"))
} else {
  Pairwise_PCA_linear_SVM_in_sample <- readRDS(paste0(rdata_path, "Pairwise_PCA_linear_SVM_in_sample.Rds"))
}
```

Let's see where balanced accuracy starts to hit 100% across the SPIs:
```{r}
Pairwise_PCA_linear_SVM_in_sample %>%
  ggplot(data=., mapping=aes(x = Num_PCs, y = balanced_accuracy)) +
  geom_line(aes(group = SPI), alpha=0.2) +
  stat_smooth(geom = "line", color = "red", size = 1.5, se=T) +
  ylab("Balanced Accuracy by Pairwise SPI") +
  xlab("# PCs Used in Linear SVM") +
  ggtitle("In-Sample Linear SVM with pySPI Pairwise SPI PCA") +
  theme(plot.title = element_text(hjust=0.5))
ggsave("plots/Pairwise_SPI_PCA_In_Sample_Linear_SVM_Balanced_Accuracy.png", width=6, height=4, 
       units="in", dpi=300)
```


In-sample inv prob

```{r}
if (!file.exists(paste0(rdata_path, "Pairwise_PCA_linear_SVM_in_sample_inv_prob.Rds"))) {
  Pairwise_in_sample_inv_prob_SVM_by_PC_list <- list()
  
  # Iterate over each pyspi SPI
  for (this_SPI in unique(all_pyspi_data$SPI)) {
    
    # Subset SPI data from overall PCA results
    groups <- pairwise_PC_scores %>%
      filter(SPI == this_SPI) %>%
      mutate(group = stringr::str_to_title(group)) %>%
      pull(group)
    
    tryCatch({
      # Run SVM for current feature
      df_res <- run_SVM_from_PCA(
        PCA_res = pairwise_PCA_list[[this_SPI]],
        group_vector = groups,
        cross_validate = FALSE,
        use_inv_prob_weighting = TRUE,
        use_SMOTE = FALSE
      ) %>%
        mutate(SPI = this_SPI)
    }, error = function(e) {
      cat("\nCould not run SVM for", this_SPI, "\n")
      print(e)
    })
    
    # Append this feature's linear SVM results to list
    Pairwise_in_sample_inv_prob_SVM_by_PC_list <- rlist::list.append(Pairwise_in_sample_inv_prob_SVM_by_PC_list,
                                                                         df_res)
  }
    # Combine SVM results across features
  Pairwise_PCA_linear_SVM_in_sample_inv_prob <- do.call(plyr::rbind.fill, Pairwise_in_sample_inv_prob_SVM_by_PC_list)
  
  saveRDS(Pairwise_PCA_linear_SVM_in_sample_inv_prob, paste0(rdata_path, "Pairwise_PCA_linear_SVM_in_sample_inv_prob.Rds"))
} else {
  Pairwise_PCA_linear_SVM_in_sample_inv_prob <- readRDS(paste0(rdata_path, "Pairwise_PCA_linear_SVM_in_sample_inv_prob.Rds"))
}
```


CV

```{r}
if (!file.exists(paste0(rdata_path, "Pairwise_PCA_linear_SVM_CV.Rds"))) {
  Pairwise_CV_SVM_by_PC_list <- list()
  
  # Iterate over each pyspi SPI
  for (this_SPI in unique(all_pyspi_data$SPI)) {
    
    # Subset SPI data from overall PCA results
    groups <- pairwise_PC_scores %>%
      filter(SPI == this_SPI) %>%
      mutate(group = stringr::str_to_title(group)) %>%
      pull(group)
    
    tryCatch({
      # Run SVM for current feature
      df_res <- run_SVM_from_PCA(
        PCA_res = pairwise_PCA_list[[this_SPI]],
        group_vector = groups,
        cross_validate = TRUE,
        use_inv_prob_weighting = FALSE,
        use_SMOTE = FALSE
      ) %>%
        mutate(SPI = this_SPI)
    }, error = function(e) {
      cat("\nCould not run SVM for", this_SPI, "\n")
      print(e)
    })
    
    # Append this feature's linear SVM results to list
    Pairwise_CV_SVM_by_PC_list <- rlist::list.append(Pairwise_CV_SVM_by_PC_list,
                                                                         df_res)
  }
    # Combine SVM results across features
  Pairwise_PCA_linear_SVM_CV <- do.call(plyr::rbind.fill, Pairwise_CV_SVM_by_PC_list)
  
  saveRDS(Pairwise_PCA_linear_SVM_CV, paste0(rdata_path, "Pairwise_PCA_linear_SVM_CV.Rds"))
} else {
  Pairwise_PCA_linear_SVM_CV <- readRDS(paste0(rdata_path, "Pairwise_PCA_linear_SVM_CV.Rds"))
}
```

CV inv prob

```{r}
if (!file.exists(paste0(rdata_path, "Pairwise_PCA_linear_SVM_CV_inv_prob.Rds"))) {
  Pairwise_CV_inv_prob_SVM_by_PC_list <- list()
  
  # Iterate over each pyspi SPI
  for (this_SPI in unique(all_pyspi_data$SPI)) {
    
    # Subset SPI data from overall PCA results
    groups <- pairwise_PC_scores %>%
      filter(SPI == this_SPI) %>%
      mutate(group = stringr::str_to_title(group)) %>%
      pull(group)
    
    tryCatch({
      # Run SVM for current feature
      df_res <- run_SVM_from_PCA(
        PCA_res = pairwise_PCA_list[[this_SPI]],
        group_vector = groups,
        cross_validate = TRUE,
        use_inv_prob_weighting = TRUE,
        use_SMOTE = FALSE
      ) %>%
        mutate(SPI = this_SPI)
    }, error = function(e) {
      cat("\nCould not run SVM for", this_SPI, "\n")
      print(e)
    })
    
    # Append this feature's linear SVM results to list
    Pairwise_CV_inv_prob_SVM_by_PC_list <- rlist::list.append(Pairwise_CV_inv_prob_SVM_by_PC_list,
                                                                         df_res)
  }
    # Combine SVM results across features
  Pairwise_PCA_linear_SVM_CV_inv_prob <- do.call(plyr::rbind.fill, Pairwise_CV_inv_prob_SVM_by_PC_list)
  
  saveRDS(Pairwise_PCA_linear_SVM_CV_inv_prob, paste0(rdata_path, "Pairwise_PCA_linear_SVM_CV_inv_prob.Rds"))
} else {
  Pairwise_PCA_linear_SVM_CV_inv_prob <- readRDS(paste0(rdata_path, "Pairwise_PCA_linear_SVM_CV_inv_prob.Rds"))
}
```

CV SMOTE

```{r}
if (!file.exists(paste0(rdata_path, "Pairwise_PCA_linear_SVM_CV_SMOTE.Rds"))) {
  Pairwise_CV_SMOTE_SVM_by_PC_list <- list()
  
  # Iterate over each pyspi SPI
  for (this_SPI in unique(all_pyspi_data$SPI)) {
    
    # Subset SPI data from overall PCA results
    groups <- pairwise_PC_scores %>%
      filter(SPI == this_SPI) %>%
      mutate(group = stringr::str_to_title(group)) %>%
      pull(group)
    
    tryCatch({
      # Run SVM for current feature
      df_res <- run_SVM_from_PCA(
        PCA_res = pairwise_PCA_list[[this_SPI]],
        group_vector = groups,
        cross_validate = TRUE,
        use_inv_prob_weighting = FALSE,
        use_SMOTE = TRUE
      ) %>%
        mutate(SPI = this_SPI)
    }, error = function(e) {
      cat("\nCould not run SVM for", this_SPI, "\n")
      print(e)
    })
    
    # Append this feature's linear SVM results to list
    Pairwise_CV_SMOTE_SVM_by_PC_list <- rlist::list.append(Pairwise_CV_SMOTE_SVM_by_PC_list,
                                                                         df_res)
  }
    # Combine SVM results across features
  Pairwise_PCA_linear_SVM_CV_SMOTE <- do.call(plyr::rbind.fill, Pairwise_CV_SMOTE_SVM_by_PC_list)
  
  saveRDS(Pairwise_PCA_linear_SVM_CV_SMOTE, paste0(rdata_path, "Pairwise_PCA_linear_SVM_CV_SMOTE.Rds"))
} else {
  Pairwise_PCA_linear_SVM_CV_SMOTE <- readRDS(paste0(rdata_path, "Pairwise_PCA_linear_SVM_CV_SMOTE.Rds"))
}
```

Combine all into one plot
```{r}
Pairwise_PCA_linear_SVM_in_sample$Method <- "In-sample"
Pairwise_PCA_linear_SVM_in_sample_inv_prob$Method <- "In-sample Inv Prob"
Pairwise_PCA_linear_SVM_CV_inv_prob$Method <- "CV Inv Prob"
Pairwise_PCA_linear_SVM_CV_SMOTE$Method <- "CV SMOTE"


mega_df <- do.call(plyr::rbind.fill, list(Pairwise_PCA_linear_SVM_in_sample,
                                          Pairwise_PCA_linear_SVM_in_sample_inv_prob,
                                          Pairwise_PCA_linear_SVM_CV_inv_prob,
                                          Pairwise_PCA_linear_SVM_CV_SMOTE))

# With smoothing
mega_df %>%
  mutate(Method = factor(Method, levels = c("In-sample",
                                            "In-sample Inv Prob",
                                            "CV",
                                            "CV Inv Prob",
                                            "CV SMOTE")),
         Unique_ID = paste0(Method, "_", SPI)) %>%
  ggplot(data=., mapping = aes(x = Num_PCs, y = balanced_accuracy)) +
  geom_line(aes(group = Unique_ID), color="gray70", alpha=0.2) +
  stat_smooth(geom = "line", aes(group = Method, color = Method), size=1.5) +
  ggtitle("Balanced Accuracy for Pairwise SPI-Wise\nLinear SVM by # PCs (Smoothed)") +
  ylab("Balanced Accuracy") +
  xlab("Number of PCs") +
  labs(color = "Classification\nMethod") +
  theme(plot.title = element_text(hjust=0.5))
ggsave("plots/Pairwise_PCA_All_Methods_Linear_SVM_Balanced_Accuracy.png", width=7, height=4, 
       units="in", dpi=300)
```



