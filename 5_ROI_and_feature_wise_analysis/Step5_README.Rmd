---
title: "Step 5: ROI+Feature Classification Analysis"
output: 
  github_document
always_allow_html: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, warning=F, message=F)
```

### Source functions
```{r}
source("../helper_functions/Linear_SVM.R")
source("../helper_functions/Visualization.R")
source("../helper_functions/Null_distributions.R")
rdata_path <- "D:/Virtual_Machines/Shared_Folder/PhD_work/data/scz/UCLA/Rdata/"
set.seed(127)
```

## In-sample SVM classification

### Simple in-sample linear SVM

We will start with a simple linear SVM classifier using all 22 features.

```{r}
# Compare all three noise processing methods
noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")

# Use e1071 SVM with a linear kernel
test_package = "e1071"
kernel = "linear"
  
# Run in-sample SVM using given package + kernel
# If the RDS object doesn't already exist, otherwise load it in
if (!file.exists(paste0(rdata_path, "Combo_wise_linear_SVM_in_sample_e1071.Rds"))) {
  combo_wise_SVM_in_sample <- run_in_sample_svm_by_input_var(rdata_path = rdata_path,
                                                             svm_kernel = kernel,
                                                             test_package = test_package,
                                                             noise_procs = noise_procs,
                                                             svm_feature_var = "Combo",
                                                             grouping_var = "Combo",
                                                             use_inv_prob_weighting = FALSE,
                                                             use_SMOTE = FALSE)
  saveRDS(combo_wise_SVM_in_sample, file=paste0(rdata_path, "Combo_wise_linear_SVM_in_sample_e1071.Rds"))
} 
```

```{r, fig.width=7, fig.height=5}
# Plot accuracy + balanced accuracy in histograms
# Control subject proportion is highlighted for accuracy
combo_wise_SVM_in_sample <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_in_sample_e1071.Rds"))

noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")
plot_class_acc_w_props(class_res = combo_wise_SVM_in_sample,
                       cv = FALSE,
                       rdata_path = rdata_path,
                       noise_procs = noise_procs)

# Save plot
ggsave("plots/Combo_Wise_In_Sample_linear_SVM_Multivar_e1071.png",
       width=7, height=5, units="in", dpi=300)
```

### In-sample linear SVM with inverse probability weighting

We can run linear SVM with the `e1071` package to directly test sample reweighting with in-sample accuracy and balanced accuracy. 

```{r}
# Compare all three noise processing methods
noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")

# Use e1071 SVM with a linear kernel
test_package = "e1071"
kernel = "linear"

# Run in-sample SVM using given package + kernel
# If the RDS object doesn't already exist, otherwise load it in
if (!file.exists(paste0(rdata_path, "Combo_wise_linear_SVM_in_sample_e1071_inv_prob.Rds"))) {
  combo_wise_SVM_in_sample_inv_prob <- run_in_sample_svm_by_input_var(rdata_path = rdata_path,
                                                                      svm_kernel = kernel,
                                                                      test_package = test_package,
                                                                      noise_procs = noise_procs,
                                                                      svm_feature_var = "Combo",
                                                                      grouping_var = "Combo",
                                                                      use_inv_prob_weighting = TRUE,
                                                                      use_SMOTE = FALSE) 
  saveRDS(combo_wise_SVM_in_sample_inv_prob, file=paste0(rdata_path, "Combo_wise_linear_SVM_in_sample_e1071_inv_prob.Rds"))
} 
```

```{r, fig.width=7, fig.height=5}
# Plot accuracy + balanced accuracy in histograms
# Control subject proportion is highlighted for accuracy
combo_wise_SVM_in_sample_inv_prob <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_in_sample_e1071_inv_prob.Rds"))

noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")
plot_class_acc_w_props(class_res = combo_wise_SVM_in_sample_inv_prob,
                       cv = FALSE,
                       rdata_path = rdata_path,
                       noise_procs = noise_procs)

# Save plot
ggsave("plots/Combo_Wise_In_Sample_linear_SVM_Multivar_e1071_inv_prob.png",
       width=7, height=5, units="in", dpi=300)
```


By assigning each subject a weight equivalent to the inverse proportion of that subject's diagnosis, the linear SVM places a higher cost on incorrectly classifying schizophrenia subjects as controls. 

This shifts the raw accuracy down to a mean of around 0.68 across the three noise-processing methods, but the balanced accuracy increases to have an average of around 0.68 also -- compared with almost exclusively values of 0.35 previously.

This indicates that inverse probability reweighting mitigates the class imbalance issue and can be carried forward into 10-fold cross-validation linear SVM.


### In-sample linear SVM with SMOTE

We can run linear SVM with the `e1071` package to directly test SMOTE with in-sample accuracy and balanced accuracy. 

```{r}
# Compare all three noise processing methods
noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")

# Use e1071 SVM with a linear kernel
test_package = "e1071"
kernel = "linear"

# Run in-sample SVM using given package + kernel
# If the RDS object doesn't already exist, otherwise load it in
if (!file.exists(paste0(rdata_path, "Combo_wise_linear_SVM_in_sample_e1071_SMOTE.Rds"))) {
  combo_wise_SVM_in_sample_SMOTE <- run_in_sample_svm_by_input_var(rdata_path = rdata_path,
                                                                      svm_kernel = kernel,
                                                                      test_package = test_package,
                                                                      noise_procs = noise_procs,
                                                                      svm_feature_var = "Combo",
                                                                      grouping_var = "Combo",
                                                                      use_inv_prob_weighting = FALSE,
                                                                      use_SMOTE = TRUE) 
  saveRDS(combo_wise_SVM_in_sample_SMOTE, file=paste0(rdata_path, "Combo_wise_linear_SVM_in_sample_e1071_SMOTE.Rds"))
} 
```

```{r, fig.width=7, fig.height=5}
# Plot accuracy + balanced accuracy in histograms
# Control subject proportion is highlighted for accuracy
combo_wise_SVM_in_sample_SMOTE <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_in_sample_e1071_SMOTE.Rds"))

noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")
plot_class_acc_w_props(class_res = combo_wise_SVM_in_sample_SMOTE,
                       cv = FALSE,
                       rdata_path = rdata_path,
                       noise_procs = noise_procs)

# Save plot
ggsave("plots/Combo_wise_In_Sample_linear_SVM_Multivar_e1071_SMOTE.png",
       width=7, height=5, units="in", dpi=300)
```


By assigning each subject a weight equivalent to the inverse proportion of that subject's diagnosis, the linear SVM places a higher cost on incorrectly classifying schizophrenia subjects as controls. 

This shifts the raw accuracy down to a mean of around 0.68 across the three noise-processing methods, but the balanced accuracy increases to have an average of around 0.68 also -- compared with almost exclusively values of 0.35 previously.

This indicates that inverse probability reweighting mitigates the class imbalance issue and can be carried forward into 10-fold cross-validation linear SVM.


## Cross-validated SVM classification

### 10-fold cross-validated linear SVM

We can implement 10-fold cross-validation (CV) with the `caret` package.

```{r}
# Noise processing methods
noise_procs <- c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")

# Use e1071 SVM with a linear kernel
test_package = "e1071"
kernel = "linear"
  
# Run in-sample SVM using given package + kernel
# If the RDS object doesn't already exist, otherwise load it in
if (!file.exists(paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071.Rds"))) {
  combo_wise_SVM_CV <- run_cv_svm_by_input_var(rdata_path = rdata_path,
                                               svm_kernel = kernel,
                                               test_package = test_package,
                                               svm_feature_var = "Combo",
                                               grouping_var = "Combo",
                                               noise_procs = noise_procs,
                                               use_inv_prob_weighting = TRUE,
                                               use_SMOTE = FALSE)
  saveRDS(combo_wise_SVM_CV, file=paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071.Rds"))
}
```

```{r, fig.width=7, fig.height=5}
# Plot accuracy + balanced accuracy in histograms
# Control subject proportion is highlighted for accuracy
noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")
combo_wise_SVM_CV <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071.Rds"))

plot_class_acc_w_props(class_res = combo_wise_SVM_CV,
                       cv = TRUE,
                       rdata_path = rdata_path,
                       noise_procs = noise_procs)

# Save plot
ggsave("plots/Combo_Wise_Linear_SVM_CV_e1071.png",
       width=7, height=5, units="in", dpi=300)
```

As with in-sample SVM, the unweighted input samples are virtually all classified as control subjects across all 82 ROIs using the 10-fold cross-validation linear SVM with caret.

### 10-fold cross-validated linear SVM with inverse probability weighting

```{r}
# Try three different noise processing methods
noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")

# Use e1071 SVM with a linear kernel
test_package = "e1071"
kernel = "linear"
  
# Run theft's multivariable classifier on each ROI and save to an RDS object
# If the RDS object doesn't already exist, otherwise load it in
if (!file.exists(paste0(rdata_path, "Combo_wise_linear_SVM_CV_inv_prob_e1071.Rds"))) {
  
  combo_wise_SVM_CV_inv_prob <- run_cv_svm_by_input_var(rdata_path = rdata_path,
                                                        svm_kernel = kernel,
                                                        test_package = test_package,
                                                        svm_feature_var = "Combo",
                                                        grouping_var = "Combo",
                                                        noise_procs = noise_procs,
                                                        use_inv_prob_weighting = TRUE,
                                                        use_SMOTE = FALSE)
  
  saveRDS(combo_wise_SVM_CV_inv_prob, file=paste0(rdata_path, "Combo_wise_linear_SVM_CV_inv_prob_e1071.Rds"))
} 
```

```{r, fig.width=7, fig.height=5}
noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")
combo_wise_SVM_CV_inv_prob <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_CV_inv_prob_e1071.Rds"))

plot_class_acc_w_props(class_res = combo_wise_SVM_CV_inv_prob,
                       cv = TRUE,
                       rdata_path = rdata_path,
                       noise_procs = noise_procs)

# Save plot
ggsave("plots/Combo_Wise_Linear_SVM_CV_e1071_inv_prob.png",
       width=7, height=5, units="in", dpi=300)
```


Surprisingly, incorporating inverse probability weighting has minimal impact when it comes to the ten-fold cross-validated SVM. Of note, the in-sample and cross-validated SVM were both run with kernlab::ksvm using default parameters.


### 10-fold cross-validated linear SVM with SMOTE

```{r}
# Try three different noise processing methods
noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")

# Use e1071 SVM with a linear kernel
test_package = "e1071"
kernel = "linear"

# Run theft's multivariable classifier on each ROI and save to an RDS object
# If the RDS object doesn't already exist, otherwise load it in
if (!file.exists(paste0(rdata_path, "Combo_wise_linear_SVM_CV_SMOTE_e1071.Rds"))) {
  
  combo_wise_SVM_CV_SMOTE <- run_cv_svm_by_input_var(rdata_path = rdata_path,
                                                     svm_kernel = kernel,
                                                     test_package = test_package,
                                                     svm_feature_var = "Combo",
                                                     grouping_var = "Combo",
                                                     noise_procs = noise_procs,
                                                     use_inv_prob_weighting = FALSE,
                                                     use_SMOTE = TRUE)
  
  saveRDS(combo_wise_SVM_CV_SMOTE, file=paste0(rdata_path, "Combo_wise_linear_SVM_CV_SMOTE_e1071.Rds"))
} 
```

```{r, fig.width=7, fig.height=5}
noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")
combo_wise_SVM_CV_SMOTE <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_CV_SMOTE_e1071.Rds"))

plot_class_acc_w_props(class_res = combo_wise_SVM_CV_SMOTE,
                       cv = TRUE,
                       rdata_path = rdata_path,
                       noise_procs = noise_procs)

# Save plot
ggsave("plots/Combo_Wise_Linear_SVM_CV_e1071_SMOTE.png",
       width=7, height=5, units="in", dpi=300)
```


Surprisingly, incorporating inverse probability weighting has minimal impact when it comes to the ten-fold cross-validated SVM. Of note, the in-sample and cross-validated SVM were both run with kernlab::ksvm using default parameters.


## Model-free shuffle null distribution

### Generating null distributions from model-free shuffles

This first model-free shuffles method is borrowed from Trent's implementation in theft. With this method, the input class labels (Schz or Control) are randomly shuffled N times, and for each iteration, the classification accuracy and balanced accuracy are calculated. This yields a null distribution of accuracies and balanced accuracies, circumventing the need for running any classification algorithms across iterations.

Here, I've run 1,000,000 iterations of the model-free shuffle, generating 1,000,000 null values for Accuracy and Balanced Accuracy, respectively. Since this method is independent of ROI/feature combo, the same null distribution can be used to compare with each ROI/feature combo separately.

```{r}
# Try three different noise processing methods
noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")

# One without minority upsampling
if (!file.exists(paste0(rdata_path, "Null_Model_Free_Shuffles.Rds"))) {
  set.seed(127) 
  model_free_shuffle_null_res <- run_model_free_n_shuffles(num_shuffles = 1000000,
                                                    rdata_path = rdata_path,
                                                    noise_procs = noise_procs)
  saveRDS(model_free_shuffle_null_res, file = paste0(rdata_path, "Null_Model_Free_Shuffles.Rds"))
} else {
  model_free_shuffle_null_res <- readRDS(paste0(rdata_path, "Null_Model_Free_Shuffles.Rds"))
}
```


### CV linear SVM

```{r}
# Calculate p values from model-free shuffle null distribution
if (!file.exists(paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071_pvals.Rds"))) {
  combo_wise_SVM_CV_pvals <- calc_empirical_nulls(class_res = combo_wise_SVM_CV,
                                                   null_data = model_free_shuffle_null_res,
                                                   grouping_var = "Combo")
  saveRDS(combo_wise_SVM_CV_pvals, file=paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071_pvals.Rds"))
} else {
  combo_wise_SVM_CV_pvals <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071_pvals.Rds"))
}

combo_wise_SVM_CV_plabs <- truncate_p_values(combo_wise_SVM_CV_pvals, N=3)
```
I've plotted the distribution of null accuracies (gray) alongside the actual accuracies (green, red, and blue) for the ROI/Feature combos per noise-processing method.

```{r, fig.width=7, fig.height=5}
plot_top_5_vars_main_vs_null(class_res_pvals = combo_wise_SVM_CV_pvals,
                             null_res = model_free_shuffle_null_res,
                             xlab = "Value",
                             ylab = "Scaled Density of Null Iterations",
                             title = "Main and Model-Free Shuffle Null Balanced Accuracy\nfor top AROMA+2P ROI/Feature Combos",
                             combo=T)

ggsave("plots/Combo_Wise_Model_Free_Shuffle_Top5_Regions_CV_SVM_Balanced_Accuracy.png", width=7, 
       height=5, units="in", dpi=300)
```

```{r}
color.me <- which(combo_wise_SVM_CV_pvals$bal_acc_p < 0.05)

combo_wise_SVM_CV_plabs %>%
  mutate(Noise_Proc = factor(Noise_Proc, levels = noise_procs)) %>%
  arrange(Noise_Proc) %>%
  dplyr::select(Noise_Proc, balanced_accuracy, bal_acc_p) %>%
  kable(.) %>%
  kable_styling(full_width = F) %>%
  row_spec(color.me, bold = T, color = "black", background = "palegreen")
```

This table summarises the number of ROIs for which raw accuracy or balanced accuracy is significantly greater than the model-free shuffle null distribution, both before and after adjusting for multiple comparisons with BH-FDR.


### CV linear SVM -- inv prob


```{r}
# Calculate p values from model-free shuffle null distribution
combo_wise_SVM_CV_inv_prob <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_CV_inv_prob_e1071.Rds"))
if (!file.exists(paste0(rdata_path, "Combo_wise_linear_SVM_CV_inv_prob_e1071_pvals.Rds"))) {
  combo_wise_SVM_CV_inv_prob_pvals <- calc_empirical_nulls(class_res = combo_wise_SVM_CV_inv_prob,
                                                   null_data = model_free_shuffle_null_res,
                                                   grouping_var = "Combo")
  saveRDS(combo_wise_SVM_CV_inv_prob_pvals, file=paste0(rdata_path, "Combo_wise_linear_SVM_CV_inv_prob_e1071_pvals.Rds"))
} else {
  combo_wise_SVM_CV_inv_prob_pvals <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_CV_inv_prob_e1071_pvals.Rds"))
}


combo_wise_SVM_CV_inv_prob_plabs <- truncate_p_values(combo_wise_SVM_CV_inv_prob_pvals)
```


```{r, fig.width=7, fig.height=5}
plot_top_5_vars_main_vs_null(class_res_pvals = combo_wise_SVM_CV_inv_prob_pvals,
                             null_res = model_free_shuffle_null_res,
                             xlab = "Value",
                             ylab = "Scaled Density of Null Iterations",
                             title = "Main and Model-Free Shuffle Null Balanced Accuracy\nfor top AROMA+2P ROI/Feature Combos, Inverse Probability",
                             combo = TRUE)

# Save plot
ggsave("plots/Combo_Wise_Model_Free_Shuffle_Top5_Regions_CV_SVM_Balanced_Accuracy_Inv_Prob.png", width=7, 
       height=5, units="in", dpi=300)
```

I've plotted the distribution of null accuracies (gray) alongside the actual accuracies (green, red, and blue) for the ROI/Feature combos per noise-processing method.

```{r}
color.me <- which(combo_wise_SVM_CV_inv_prob_pvals$bal_acc_p < 0.05)

combo_wise_SVM_CV_inv_prob_plabs %>%
  mutate(Noise_Proc = factor(Noise_Proc, levels = noise_procs)) %>%
  arrange(Noise_Proc) %>%
  dplyr::select(Noise_Proc, balanced_accuracy, bal_acc_p) %>%
  kable(.) %>%
  kable_styling(full_width = F) %>%
  row_spec(color.me, bold = T, color = "black", background = "palegreen")
```

This table summarises the number of ROIs for which raw accuracy or balanced accuracy is significantly greater than the model-free shuffle null distribution, both before and after adjusting for multiple comparisons with BH-FDR.

### CV linear SVM -- SMOTE

```{r}
# Calculate p values from model-free shuffle null distribution
combo_wise_SVM_CV_SMOTE <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_CV_SMOTE_e1071.Rds"))
if (!file.exists(paste0(rdata_path, "Combo_wise_linear_SVM_CV_SMOTE_e1071_pvals.Rds"))) {
  combo_wise_SVM_CV_SMOTE_pvals <- calc_empirical_nulls(class_res = combo_wise_SVM_CV_SMOTE,
                                                   null_data = model_free_shuffle_null_res,
                                                   grouping_var = "Combo")
  saveRDS(combo_wise_SVM_CV_SMOTE_pvals, file=paste0(rdata_path, "Combo_wise_linear_SVM_CV_SMOTE_e1071_pvals.Rds"))
} else {
  combo_wise_SVM_CV_SMOTE_pvals <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_CV_SMOTE_e1071_pvals.Rds"))
}


combo_wise_SVM_CV_SMOTE_plabs <- truncate_p_values(combo_wise_SVM_CV_SMOTE_pvals)
```

```{r, fig.width=7, fig.height=5}
plot_top_5_vars_main_vs_null(class_res_pvals = combo_wise_SVM_CV_SMOTE_pvals,
                             null_res = model_free_shuffle_null_res,
                             xlab = "Value",
                             ylab = "Scaled Density of Null Iterations",
                             title = "Main and Model-Free Shuffle Null Balanced Accuracy\nfor top AROMA+2P ROI/Feature Combos, SMOTE",
                             combo = TRUE)

# Save plot
ggsave("plots/Combo_Wise_Model_Free_Shuffle_Top5_Regions_CV_SVM_Balanced_Accuracy_SMOTE.png", width=7, 
       height=5, units="in", dpi=300)
```


I've plotted the distribution of null accuracies (gray) alongside the actual accuracies (green, red, and blue) for the ROI/Feature combos per noise-processing method.

```{r}
color.me <- which(combo_wise_SVM_CV_SMOTE_pvals$bal_acc_p < 0.05)

combo_wise_SVM_CV_SMOTE_plabs %>%
  mutate(Noise_Proc = factor(Noise_Proc, levels = noise_procs)) %>%
  arrange(Noise_Proc) %>%
  dplyr::select(Noise_Proc, balanced_accuracy, bal_acc_p) %>%
  kable(.) %>%
  kable_styling(full_width = F) %>%
  row_spec(color.me, bold = T, color = "black", background = "palegreen")
```

This table summarises the number of ROIs for which raw accuracy or balanced accuracy is significantly greater than the model-free shuffle null distribution, both before and after adjusting for multiple comparisons with BH-FDR.

## Empirical model-based pooled null distribution

### Generating null distributions from pooled null model fits

In contrast to the model-free shuffle method, here we are actually shuffling the input class labels right before running the linear SVM over N=100 iterations per ROI (N=82) and pooling the resulting accuracy and balanced accuracy values, to generate empirical null distributions of N=1,000 data points each, respectively.

### In-sample

```{r}
# Run null model permutation function
noise_procs <- c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")
svm_kernel <- "linear"
set.seed(127)

if (!file.exists(paste0(rdata_path, "Combo_wise_model_permutation_null_in_sample.Rds"))) {
  model_permutation_null_in_sample <- run_null_model_n_permutations(rdata_path,
                                                                    noise_procs = noise_procs,
                                                                    grouping_var = "Combo",
                                                                    svm_feature_var = "Combo",
                                                                    num_permutations = 100,
                                                                    use_inv_prob_weighting = FALSE,
                                                                    cross_validate = FALSE)
  
  saveRDS(model_permutation_null_in_sample, file=paste0(rdata_path, "Combo_wise_model_permutation_null_in_sample.Rds"))
} else {
  model_permutation_null_in_sample <- readRDS(paste0(rdata_path, "Combo_wise_model_permutation_null_in_sample.Rds"))
}
```


```{r}
combo_wise_SVM_in_sample <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_in_sample_e1071.Rds"))

if (!file.exists(paste0(rdata_path, "Combo_wise_In_Sample_Null_Model_Fits_pvals.Rds"))) {
  combo_wise_SVM_in_sample_pvals <- calc_empirical_nulls(class_res = combo_wise_SVM_in_sample,
                                                          null_data = model_permutation_null_in_sample,
                                                          grouping_var = "Combo")
  saveRDS(combo_wise_SVM_in_sample_pvals, file=paste0(rdata_path, "Combo_wise_In_Sample_Null_Model_Fits_pvals.Rds"))
} else {
  combo_wise_SVM_in_sample_pvals <- readRDS(paste0(rdata_path, "Combo_wise_In_Sample_Null_Model_Fits_pvals.Rds"))
}

combo_wise_SVM_in_sample_plabs <- truncate_p_values(combo_wise_SVM_in_sample_pvals)
```

```{r, fig.width=7, fig.height=5}
plot_top_5_vars_main_vs_null(class_res_pvals = combo_wise_SVM_in_sample_pvals,
                             null_res = model_permutation_null_in_sample,
                             xlab = "Value",
                             ylab = "Scaled Density of Null Iterations",
                             title = "Main and Null Model Fit Balanced Accuracy\nfor top AROMA+2P ROI/Feature Combos, In-Sample",
                             combo = TRUE)

# Save plots
ggsave("plots/Combo_Wise_Null_Model_Fit_Top5_Regions_In_Sample_Balanced_Accuracy.png", width=7, 
       height=5, units="in", dpi=300)
```

The fitted empirical null model distribution is fairly similar to the real accuracy and balanced accuracy values using in-sample linear SVM with no reweighting. 

```{r}
color.me <- which(combo_wise_SVM_in_sample_pvals$bal_acc_p < 0.05)

combo_wise_SVM_in_sample_plabs %>%
  mutate(Noise_Proc = factor(Noise_Proc, levels = noise_procs)) %>%
  arrange(Noise_Proc) %>%
  dplyr::select(Noise_Proc, balanced_accuracy, bal_acc_p) %>%
  kable(.) %>%
  kable_styling(full_width = F) %>%
  row_spec(color.me, bold = T, color = "black", background = "palegreen")
```

### In-sample, inverse probability weighted

```{r}
# Run null model permutation function
noise_procs <- c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")
svm_kernel <- "linear"
set.seed(127)

if (!file.exists(paste0(rdata_path, "Combo_wise_model_permutation_null_in_sample_inv_prob.Rds"))) {
  model_permutation_null_in_sample_inv_prob <- run_null_model_n_permutations(rdata_path,
                                                                    noise_procs = noise_procs,
                                                                    grouping_var = "Combo",
                                                                    svm_feature_var = "Combo",
                                                                    num_permutations = 100,
                                                                    use_inv_prob_weighting = TRUE,
                                                                    cross_validate = FALSE)
  
  saveRDS(model_permutation_null_in_sample_inv_prob, file=paste0(rdata_path, "Combo_wise_model_permutation_null_in_sample_inv_prob.Rds"))
} else {
  model_permutation_null_in_sample_inv_prob <- readRDS(paste0(rdata_path, "Combo_wise_model_permutation_null_in_sample_inv_prob.Rds"))
}
```


```{r}
combo_wise_SVM_in_sample_inv_prob <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_in_sample_e1071_inv_prob.Rds"))

if (!file.exists(paste0(rdata_path, "Combo_wise_In_Sample_Null_Model_Fits_pvals_inv_prob.Rds"))) {
  combo_wise_SVM_in_sample_inv_prob_pvals <- calc_empirical_nulls(class_res = combo_wise_SVM_in_sample_inv_prob,
                                                              null_data = model_permutation_null_in_sample_inv_prob,
                                                              grouping_var = "Combo")
  saveRDS(combo_wise_SVM_in_sample_inv_prob_pvals, file=paste0(rdata_path, "Combo_wise_In_Sample_Null_Model_Fits_pvals_inv_prob.Rds"))
} else {
  combo_wise_SVM_in_sample_inv_prob_pvals <- readRDS(paste0(rdata_path, "Combo_wise_In_Sample_Null_Model_Fits_pvals_inv_prob.Rds"))
}

combo_wise_SVM_in_sample_inv_prob_plabs <- truncate_p_values(combo_wise_SVM_in_sample_inv_prob_pvals)
```

```{r, fig.width=7, fig.height=5}
plot_top_5_vars_main_vs_null(class_res_pvals = combo_wise_SVM_in_sample_inv_prob_pvals,
                             null_res = model_permutation_null_in_sample_inv_prob,
                             xlab = "Value",
                             ylab = "Scaled Density of Null Iterations",
                             title = "Main and Null Model Fit Balanced Accuracy\nfor top AROMA+2P ROI/Feature Combos, In-Sample Inv Prob",
                             combo = TRUE)

# Save plot
ggsave("plots/Combo_Wise_Null_Model_Fit_Top5_Regions_In_Sample_Inv_Prob_Balanced_Accuracy.png", width=7, 
       height=5, units="in", dpi=300)
```

The fitted empirical null model distribution is fairly similar to the real accuracy and balanced accuracy values using in-sample linear SVM with no reweighting. 

```{r}
color.me <- which(combo_wise_SVM_in_sample_inv_prob_pvals$bal_acc_p < 0.05)

combo_wise_SVM_in_sample_inv_prob_plabs %>%
  mutate(Noise_Proc = factor(Noise_Proc, levels = noise_procs)) %>%
  arrange(Noise_Proc) %>%
  dplyr::select(Noise_Proc, balanced_accuracy, bal_acc_p) %>%
  kable(.) %>%
  kable_styling(full_width = F) %>%
  row_spec(color.me, bold = T, color = "black", background = "palegreen")
```


### CV, inverse probability weighted

```{r}
# Run null model permutation function
noise_procs <- c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")
svm_kernel <- "linear"
set.seed(127)

if (!file.exists(paste0(rdata_path, "Combo_wise_model_permutation_null_CV_inv_prob.Rds"))) {
  model_permutation_null_CV_inv_prob <- run_null_model_n_permutations(rdata_path,
                                                                    noise_procs = noise_procs,
                                                                    grouping_var = "Combo",
                                                                    svm_feature_var = "Combo",
                                                                    num_permutations = 100,
                                                                    use_inv_prob_weighting = TRUE,
                                                                    cross_validate = TRUE)
  
  saveRDS(model_permutation_null_CV_inv_prob, file=paste0(rdata_path, "Combo_wise_model_permutation_null_CV_inv_prob.Rds"))
} else {
  model_permutation_null_CV_inv_prob <- readRDS(paste0(rdata_path, "Combo_wise_model_permutation_null_CV_inv_prob.Rds"))
}
```


```{r}
combo_wise_SVM_CV_inv_prob <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_CV_inv_prob_e1071.Rds"))

if (!file.exists(paste0(rdata_path, "Combo_wise_CV_Null_Model_Fits_pvals_inv_prob.Rds"))) {
  combo_wise_SVM_CV_inv_prob_pvals <- calc_empirical_nulls(class_res = combo_wise_SVM_CV_inv_prob,
                                                              null_data = model_permutation_null_CV_inv_prob,
                                                              grouping_var = "Combo")
  saveRDS(combo_wise_SVM_CV_inv_prob_pvals, file=paste0(rdata_path, "Combo_wise_CV_Null_Model_Fits_pvals_inv_prob.Rds"))
} else {
  combo_wise_SVM_CV_inv_prob_pvals <- readRDS(paste0(rdata_path, "Combo_wise_CV_Null_Model_Fits_pvals_inv_prob.Rds"))
}

combo_wise_SVM_CV_inv_prob_plabs <- truncate_p_values(combo_wise_SVM_CV_inv_prob_pvals)
```

```{r, fig.width=7, fig.height=5}
plot_top_5_vars_main_vs_null(class_res_pvals = combo_wise_SVM_CV_inv_prob_pvals,
                             null_res = model_permutation_null_CV_inv_prob,
                             xlab = "Value",
                             ylab = "Scaled Density of Null Iterations",
                             title = "Main and Null Model Fit Balanced Accuracy\nfor top AROMA+2P ROI/Feature Combos, CV Inv Prob",
                             combo = TRUE)

# Save plot
ggsave("plots/Combo_Wise_Null_Model_Fit_CV_Inv_Prob_Balanced_Accuracy.png", width=7, 
       height=5, units="in", dpi=300)
```

The fitted empirical null model distribution is fairly similar to the real accuracy and balanced accuracy values using in-sample linear SVM with no reweighting. 

```{r}
color.me <- which(combo_wise_SVM_CV_inv_prob_pvals$bal_acc_p < 0.05)

combo_wise_SVM_CV_inv_prob_plabs %>%
  mutate(Noise_Proc = factor(Noise_Proc, levels = noise_procs)) %>%
  arrange(Noise_Proc) %>%
  dplyr::select(Noise_Proc, balanced_accuracy, bal_acc_p) %>%
  kable(.) %>%
  kable_styling(full_width = F) %>%
  row_spec(color.me, bold = T, color = "black", background = "palegreen")
```


### CV, SMOTE

```{r}
# Run null model permutation function
noise_procs <- c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")
svm_kernel <- "linear"
set.seed(127)

if (!file.exists(paste0(rdata_path, "Combo_wise_model_permutation_null_CV_SMOTE.Rds"))) {
  model_permutation_null_CV_SMOTE <- run_null_model_n_permutations(rdata_path,
                                                                    noise_procs = noise_procs,
                                                                    grouping_var = "Combo",
                                                                    svm_feature_var = "Combo",
                                                                    num_permutations = 100,
                                                                    use_inv_prob_weighting = TRUE,
                                                                    cross_validate = TRUE)
  
  saveRDS(model_permutation_null_CV_SMOTE, file=paste0(rdata_path, "Combo_wise_model_permutation_null_CV_SMOTE.Rds"))
} else {
  model_permutation_null_CV_SMOTE <- readRDS(paste0(rdata_path, "Combo_wise_model_permutation_null_CV_SMOTE.Rds"))
}
```

```{r}
combo_wise_SVM_CV_SMOTE <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_CV_SMOTE_e1071.Rds"))

if (!file.exists(paste0(rdata_path, "Combo_wise_CV_Null_Model_Fits_pvals_SMOTE.Rds"))) {
  combo_wise_SVM_CV_SMOTE_pvals <- calc_empirical_nulls(class_res = combo_wise_SVM_CV_SMOTE,
                                                              null_data = model_permutation_null_CV_SMOTE,
                                                              grouping_var = "Combo")
  saveRDS(combo_wise_SVM_CV_SMOTE_pvals, file=paste0(rdata_path, "Combo_wise_CV_Null_Model_Fits_pvals_SMOTE.Rds"))
} else {
  combo_wise_SVM_CV_SMOTE_pvals <- readRDS(paste0(rdata_path, "Combo_wise_CV_Null_Model_Fits_pvals_SMOTE.Rds"))
}

combo_wise_SVM_CV_SMOTE_plabs <- truncate_p_values(combo_wise_SVM_CV_SMOTE_pvals)
```

```{r, fig.width=7, fig.height=5}
plot_top_5_vars_main_vs_null(class_res_pvals = combo_wise_SVM_CV_SMOTE_pvals,
                             null_res = model_permutation_null_CV_SMOTE,
                             xlab = "Value",
                             ylab = "Scaled Density of Null Iterations",
                             title = "Main and Null Model Fit Balanced Accuracy\nfor top AROMA+2P ROI/Feature Combos, CV SMOTE",
                             combo = TRUE)

# Save plot
ggsave("plots/Combo_Wise_Null_Model_Fit_Top5_Regions_CV_SMOTE_Balanced_Accuracy.png", width=7, 
       height=5, units="in", dpi=300)
```

The fitted empirical null model distribution is fairly similar to the real accuracy and balanced accuracy values using in-sample linear SVM with no reweighting. 

```{r}
color.me <- which(combo_wise_SVM_CV_SMOTE_pvals$bal_acc_p < 0.05)

combo_wise_SVM_CV_SMOTE_plabs %>%
  mutate(Noise_Proc = factor(Noise_Proc, levels = noise_procs)) %>%
  arrange(Noise_Proc) %>%
  dplyr::select(Noise_Proc, balanced_accuracy, bal_acc_p) %>%
  kable(.) %>%
  kable_styling(full_width = F) %>%
  row_spec(color.me, bold = T, color = "black", background = "palegreen")
```


## Comparing model-free shuffle with pooled empirical null distributions

```{r, fig.width = 7, fig.height = 7}
# In-sample inverse probability
in_sample_inv_prob_p <- model_free_shuffle_null_res %>%
  mutate(Null_Type = "Model-Free Shuffle") %>%
  plyr::rbind.fill(model_permutation_null_in_sample_inv_prob %>% 
                     mutate(Null_Type = "Null Model Fit, In-sample Inv Prob")) %>%
  mutate(Null_Type = factor(Null_Type, levels = c("Model-Free Shuffle",
                                                  "Null Model Fit, In-sample Inv Prob",
                                                  "Null Model Fit, CV Inv Prob",
                                                  "Null Model Fit, CV SMOTE"))) %>%
  ggplot(data=., mapping=aes(x=balanced_accuracy, fill=Null_Type)) +
  geom_histogram(alpha=0.5, 
                 aes(y=0.5*..density..), 
                 position="identity",
                 bins = 50) +
  scale_x_continuous(limits = c(0.3, 1.01)) +
  ylab("") +
  xlab("") +
  labs(fill = "Null Type") +
  scale_fill_manual(values = list("Model-Free Shuffle" = "gray70", 
                                  "Null Model Fit, In-sample Inv Prob" = "coral",
                                  "Null Model Fit, CV Inv Prob" = "dodgerblue",
                                  "Null Model Fit, CV SMOTE" = "green"))

# CV inverse probability
CV_inv_prob_p <- model_free_shuffle_null_res %>%
  mutate(Null_Type = "Model-Free Shuffle") %>%
  plyr::rbind.fill(model_permutation_null_CV_inv_prob %>% 
                     mutate(Null_Type = "Null Model Fit, CV Inv Prob")) %>%
  mutate(Null_Type = factor(Null_Type, levels = c("Model-Free Shuffle",
                                                  "Null Model Fit, In-sample Inv Prob",
                                                  "Null Model Fit, CV Inv Prob",
                                                  "Null Model Fit, CV SMOTE"))) %>%
  ggplot(data=., mapping=aes(x=balanced_accuracy, fill=Null_Type)) +
  geom_histogram(alpha=0.5, 
                 aes(y=0.5*..density..), 
                 position="identity",
                 bins = 50) +
  scale_x_continuous(limits = c(0.3, 1.01)) +
  ylab("Scaled Density") +
  xlab("") +
  labs(fill = "Null Type") +
  scale_fill_manual(values = list("Model-Free Shuffle" = "gray70", 
                                  "Null Model Fit, In-sample Inv Prob" = "coral",
                                  "Null Model Fit, CV Inv Prob" = "dodgerblue",
                                  "Null Model Fit, CV SMOTE" = "green"))

# CV SMOTE
CV_SMOTE_p <- model_free_shuffle_null_res %>%
  mutate(Null_Type = "Model-Free Shuffle") %>%
  plyr::rbind.fill(model_permutation_null_CV_SMOTE %>% 
                     mutate(Null_Type = "Null Model Fit, CV SMOTE")) %>%
  mutate(Null_Type = factor(Null_Type, levels = c("Model-Free Shuffle",
                                                  "Null Model Fit, In-sample Inv Prob",
                                                  "Null Model Fit, CV Inv Prob",
                                                  "Null Model Fit, CV SMOTE"))) %>%
  ggplot(data=., mapping=aes(x=balanced_accuracy, fill=Null_Type)) +
  geom_histogram(alpha=0.5, 
                 aes(y=0.5*..density..), 
                 position="identity",
                 bins = 50) +
  scale_x_continuous(limits = c(0.3, 1.01)) +
  ylab("") +
  xlab("Balanced Accuracy") +
  labs(fill = "Null Type") +
  scale_fill_manual(values = list("Model-Free Shuffle" = "gray70", 
                                  "Null Model Fit, In-sample Inv Prob" = "coral",
                                  "Null Model Fit, CV Inv Prob" = "dodgerblue",
                                  "Null Model Fit, CV SMOTE" = "green"))

in_sample_inv_prob_p / CV_inv_prob_p / CV_SMOTE_p  + 
  plot_annotation(title = "Null Distributions by Model Type") + 
  plot_layout(guides = "collect") & 
  theme(legend.position = 'bottom') &
  guides(fill = guide_legend(nrow=2,byrow=TRUE))
ggsave("plots/Null_Distributions_by_Model_Type.png",
       width = 7, height = 7, units = "in", dpi=300)
```

 