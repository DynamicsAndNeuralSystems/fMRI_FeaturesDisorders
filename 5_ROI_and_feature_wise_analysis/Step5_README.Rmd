---
title: "Step 5: ROI+Feature Classification Analysis"
output: 
  github_document
always_allow_html: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, warning=F, message=F)
```

### Source functions
```{r}
source("../helper_functions/SVM_functions.R")
rdata_path <- "D:/Virtual_Machines/Shared_Folder/PhD_work/data/scz/UCLA/Rdata/"
library(knitr)
library(kableExtra)
library(patchwork)
set.seed(127)
```

## In-sample SVM classification

### Simple in-sample linear SVM

We will start with a simple linear SVM classifier using all 22 features.

```{r}
# Compare all three noise processing methods
noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")

# Use e1071 SVM with a linear kernel
test_package = "e1071"
kernel = "linear"
  
# Run in-sample SVM using given package + kernel
# If the RDS object doesn't already exist, otherwise load it in
if (!file.exists(paste0(rdata_path, "Combo_wise_linear_SVM_in_sample_e1071.Rds"))) {
  combo_wise_SVM_in_sample <- run_in_sample_svm_by_input_var(rdata_path = rdata_path,
                                                             svm_kernel = kernel,
                                                             test_package = test_package,
                                                             noise_procs = noise_procs,
                                                             svm_feature_var = "Combo",
                                                             grouping_var = "Combo",
                                                             use_inv_prob_weighting = FALSE,
                                                             use_SMOTE = FALSE)
  saveRDS(combo_wise_SVM_in_sample, file=paste0(rdata_path, "Combo_wise_linear_SVM_in_sample_e1071.Rds"))
} 
```

```{r, fig.width=7, fig.height=5}
# Plot accuracy + balanced accuracy in histograms
# Control subject proportion is highlighted for accuracy
combo_wise_SVM_in_sample <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_in_sample_e1071.Rds"))

noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")
plot_class_acc_w_props(class_res = combo_wise_SVM_in_sample,
                       cv = FALSE,
                       rdata_path = rdata_path,
                       noise_procs = noise_procs)
```

```{r, eval=F, echo=F}
# Save plot
ggsave("plots/Combo_Wise_In_Sample_linear_SVM_Multivar_e1071.png",
       width=7, height=5, units="in", dpi=300)
```

### In-sample linear SVM with inverse probability weighting

We can run linear SVM with the `e1071` package to directly test sample reweighting with in-sample accuracy and balanced accuracy. 

```{r}
# Compare all three noise processing methods
noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")

# Use e1071 SVM with a linear kernel
test_package = "e1071"
kernel = "linear"

# Run in-sample SVM using given package + kernel
# If the RDS object doesn't already exist, otherwise load it in
if (!file.exists(paste0(rdata_path, "Combo_wise_linear_SVM_in_sample_e1071_inv_prob.Rds"))) {
  combo_wise_SVM_in_sample_inv_prob <- run_in_sample_svm_by_input_var(rdata_path = rdata_path,
                                                                      svm_kernel = kernel,
                                                                      test_package = test_package,
                                                                      noise_procs = noise_procs,
                                                                      svm_feature_var = "Combo",
                                                                      grouping_var = "Combo",
                                                                      use_inv_prob_weighting = TRUE,
                                                                      use_SMOTE = FALSE) 
  saveRDS(combo_wise_SVM_in_sample_inv_prob, file=paste0(rdata_path, "Combo_wise_linear_SVM_in_sample_e1071_inv_prob.Rds"))
} 
```

```{r, fig.width=7, fig.height=5}
# Plot accuracy + balanced accuracy in histograms
# Control subject proportion is highlighted for accuracy
combo_wise_SVM_in_sample_inv_prob <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_in_sample_e1071_inv_prob.Rds"))

noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")
plot_class_acc_w_props(class_res = combo_wise_SVM_in_sample_inv_prob,
                       cv = FALSE,
                       rdata_path = rdata_path,
                       noise_procs = noise_procs)
```

```{r, eval=F, echo=F}
# Save plot
ggsave("plots/Combo_Wise_In_Sample_linear_SVM_Multivar_e1071_inv_prob.png",
       width=7, height=5, units="in", dpi=300)
```


By assigning each subject a weight equivalent to the inverse proportion of that subject's diagnosis, the linear SVM places a higher cost on incorrectly classifying schizophrenia subjects as controls. 

This shifts the raw accuracy down to a mean of around 0.68 across the three noise-processing methods, but the balanced accuracy increases to have an average of around 0.68 also -- compared with almost exclusively values of 0.35 previously.

This indicates that inverse probability reweighting mitigates the class imbalance issue and can be carried forward into 10-fold cross-validation linear SVM.


### In-sample linear SVM with SMOTE

We can run linear SVM with the `e1071` package to directly test SMOTE with in-sample accuracy and balanced accuracy. 

```{r}
# Compare all three noise processing methods
noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")

# Use e1071 SVM with a linear kernel
test_package = "e1071"
kernel = "linear"

# Run in-sample SVM using given package + kernel
# If the RDS object doesn't already exist, otherwise load it in
if (!file.exists(paste0(rdata_path, "Combo_wise_linear_SVM_in_sample_e1071_SMOTE.Rds"))) {
  combo_wise_SVM_in_sample_SMOTE <- run_in_sample_svm_by_input_var(rdata_path = rdata_path,
                                                                      svm_kernel = kernel,
                                                                      test_package = test_package,
                                                                      noise_procs = noise_procs,
                                                                      svm_feature_var = "Combo",
                                                                      grouping_var = "Combo",
                                                                      use_inv_prob_weighting = FALSE,
                                                                      use_SMOTE = TRUE) 
  saveRDS(combo_wise_SVM_in_sample_SMOTE, file=paste0(rdata_path, "Combo_wise_linear_SVM_in_sample_e1071_SMOTE.Rds"))
} 
```

```{r, fig.width=7, fig.height=5}
# Plot accuracy + balanced accuracy in histograms
# Control subject proportion is highlighted for accuracy
combo_wise_SVM_in_sample_SMOTE <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_in_sample_e1071_SMOTE.Rds"))

noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")
plot_class_acc_w_props(class_res = combo_wise_SVM_in_sample_SMOTE,
                       cv = FALSE,
                       rdata_path = rdata_path,
                       noise_procs = noise_procs)
```

```{r, eval=F, echo=F}
# Save plot
ggsave("plots/Combo_wise_In_Sample_linear_SVM_Multivar_e1071_SMOTE.png",
       width=7, height=5, units="in", dpi=300)
```


By assigning each subject a weight equivalent to the inverse proportion of that subject's diagnosis, the linear SVM places a higher cost on incorrectly classifying schizophrenia subjects as controls. 

This shifts the raw accuracy down to a mean of around 0.68 across the three noise-processing methods, but the balanced accuracy increases to have an average of around 0.68 also -- compared with almost exclusively values of 0.35 previously.

This indicates that inverse probability reweighting mitigates the class imbalance issue and can be carried forward into 10-fold cross-validation linear SVM.


## Cross-validated SVM classification

### 10-fold cross-validated linear SVM

We can implement 10-fold cross-validation (CV) with the `caret` package.

```{r}
# Noise processing methods
noise_procs <- c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")

# Use e1071 SVM with a linear kernel
test_package = "e1071"
kernel = "linear"
  
# Run in-sample SVM using given package + kernel
# If the RDS object doesn't already exist, otherwise load it in
if (!file.exists(paste0(rdata_path, "Combo_wise_linear_SVM_CV.Rds"))) {
  combo_wise_SVM_CV <- run_cv_svm_by_input_var(rdata_path = rdata_path,
                                               svm_kernel = kernel,
                                               test_package = test_package,
                                               svm_feature_var = "Combo",
                                               grouping_var = "Combo",
                                               noise_procs = noise_procs,
                                               use_inv_prob_weighting = TRUE,
                                               use_SMOTE = FALSE)
  saveRDS(combo_wise_SVM_CV, file=paste0(rdata_path, "Combo_wise_linear_SVM_CV.Rds"))
}
```

```{r, fig.width=7, fig.height=5}
# Plot accuracy + balanced accuracy in histograms
# Control subject proportion is highlighted for accuracy
noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")
combo_wise_SVM_CV <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_CV.Rds"))

plot_class_acc_w_props(class_res = combo_wise_SVM_CV,
                       cv = TRUE,
                       rdata_path = rdata_path,
                       noise_procs = noise_procs)
```

```{r, echo=F, eval=F}
# Save plot
ggsave("plots/Combo_Wise_Linear_SVM_CV_e1071.png",
       width=7, height=5, units="in", dpi=300)
```

As with in-sample SVM, the unweighted input samples are virtually all classified as control subjects across all 82 ROIs using the 10-fold cross-validation linear SVM with caret.

### 10-fold cross-validated linear SVM with inverse probability weighting

```{r}
# Try three different noise processing methods
noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")

# Use e1071 SVM with a linear kernel
test_package = "e1071"
kernel = "linear"
  
# Run theft's multivariable classifier on each ROI and save to an RDS object
# If the RDS object doesn't already exist, otherwise load it in
if (!file.exists(paste0(rdata_path, "Combo_wise_linear_SVM_CV_inv_prob.Rds"))) {
  
  combo_wise_SVM_CV_inv_prob <- run_cv_svm_by_input_var(rdata_path = rdata_path,
                                                        svm_kernel = kernel,
                                                        test_package = test_package,
                                                        svm_feature_var = "Combo",
                                                        grouping_var = "Combo",
                                                        noise_procs = noise_procs,
                                                        use_inv_prob_weighting = TRUE,
                                                        use_SMOTE = FALSE)
  
  saveRDS(combo_wise_SVM_CV_inv_prob, file=paste0(rdata_path, "Combo_wise_linear_SVM_CV_inv_prob.Rds"))
} 
```

```{r, fig.width=7, fig.height=5}
noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")
combo_wise_SVM_CV_inv_prob <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_CV_inv_prob.Rds"))

plot_class_acc_w_props(class_res = combo_wise_SVM_CV_inv_prob,
                       cv = TRUE,
                       rdata_path = rdata_path,
                       noise_procs = noise_procs)
```
```{r, eval=F, echo=F}
# Save plot
ggsave("plots/Combo_Wise_Linear_SVM_CV_e1071_inv_prob.png",
       width=7, height=5, units="in", dpi=300)
```


Surprisingly, incorporating inverse probability weighting has minimal impact when it comes to the ten-fold cross-validated SVM. Of note, the in-sample and cross-validated SVM were both run with kernlab::ksvm using default parameters.


### 10-fold cross-validated linear SVM with SMOTE

```{r}
# Try three different noise processing methods
noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")

# Use e1071 SVM with a linear kernel
test_package = "e1071"
kernel = "linear"

# Run theft's multivariable classifier on each ROI and save to an RDS object
# If the RDS object doesn't already exist, otherwise load it in
if (!file.exists(paste0(rdata_path, "Combo_wise_linear_SVM_CV_SMOTE.Rds"))) {
  
  combo_wise_SVM_CV_SMOTE <- run_cv_svm_by_input_var(rdata_path = rdata_path,
                                                     svm_kernel = kernel,
                                                     test_package = test_package,
                                                     svm_feature_var = "Combo",
                                                     grouping_var = "Combo",
                                                     noise_procs = noise_procs,
                                                     use_inv_prob_weighting = FALSE,
                                                     use_SMOTE = TRUE)
  
  saveRDS(combo_wise_SVM_CV_SMOTE, file=paste0(rdata_path, "Combo_wise_linear_SVM_CV_SMOTE.Rds"))
} 
```

```{r, fig.width=7, fig.height=5}
noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")
combo_wise_SVM_CV_SMOTE <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_CV_SMOTE.Rds"))

plot_class_acc_w_props(class_res = combo_wise_SVM_CV_SMOTE,
                       cv = TRUE,
                       rdata_path = rdata_path,
                       noise_procs = noise_procs)
```
```{r, eval=F, echo=F}
# Save plot
ggsave("plots/Combo_Wise_Linear_SVM_CV_e1071_SMOTE.png",
       width=7, height=5, units="in", dpi=300)
```


Surprisingly, incorporating inverse probability weighting has minimal impact when it comes to the ten-fold cross-validated SVM. Of note, the in-sample and cross-validated SVM were both run with kernlab::ksvm using default parameters.


## Null models

### Generating null distributions from model-free shuffles

```{r}
# Try three different noise processing methods
noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")

# One without minority upsampling
if (!file.exists(paste0(rdata_path, "Null_Model_Free_Shuffles.Rds"))) {
  set.seed(127) 
  model_free_shuffle_null_res <- run_model_free_n_shuffles(num_shuffles = 1000000,
                                                    rdata_path = rdata_path,
                                                    noise_procs = noise_procs)
  saveRDS(model_free_shuffle_null_res, file = paste0(rdata_path, "Null_Model_Free_Shuffles.Rds"))
} else {
  model_free_shuffle_null_res <- readRDS(paste0(rdata_path, "Null_Model_Free_Shuffles.Rds"))
}
```

### Deriving p-values using model-free shuffle null distributions

```{r}
if (!file.exists(paste0(rdata_path, "Combo_wise_10FCV_linear_SVM_e1071_pvals.Rds"))) {
  combo_wise_SVM_CV_pvals <- calc_empirical_nulls(class_res = combo_wise_SVM_CV,
                                                        null_data = model_free_shuffle_null_res,
                                                        grouping_var = "All")
  saveRDS(combo_wise_SVM_CV_pvals, file=paste0(rdata_path, "Combo_wise_10FCV_linear_SVM_e1071_pvals.Rds"))
  
} else {
  combo_wise_SVM_CV_pvals <- readRDS(paste0(rdata_path, "Combo_wise_10FCV_linear_SVM_e1071_pvals.Rds"))
}

combo_wise_SVM_CV_plabs <- combo_wise_SVM_CV_pvals %>%
  mutate(acc_p = scales::scientific(acc_p, digits = 3),
         bal_acc_p = scales::scientific(bal_acc_p, digits = 3),
         acc_p_adj = scales::scientific(acc_p_adj, digits = 3),
         bal_acc_p_adj = scales::scientific(bal_acc_p_adj, digits = 3))
```

Balanced accuracy:
```{r, fig.width=7, fig.height=5}
combo_wise_SVM_CV_pvals %>%
  ggplot(data=.) +
  geom_histogram(data = subset(model_free_shuffle_null_res, Type=="null"),
                 aes(x = balanced_accuracy, y=0.5*..density..), 
                 bins = 50,
                 alpha=0.6, position="identity",
                 fill = "gray70") +
  geom_vline(mapping=aes(xintercept = balanced_accuracy, color = Noise_Proc), size=1.2) +
  xlab("Balanced Accuracy from n=1,000,000 Model-Free Shuffles") +
  ylab("Scaled Density") +
  labs(color = "Noise Processing") +
  theme(strip.text.y.left = element_text(angle=0),
        strip.placement = "outside",
        legend.position = "bottom",
        legend.direction = "horizontal")
```

```{r, eval=F, echo=F}
# Save plot
ggsave("plots/Combo_Wise_Main_vs_Null_BAcc_10FCV_Linear_SVM.png",
       width=8, height=5, units="in", dpi=300)
```

Summary statistics:
```{r}
combo_wise_SVM_CV_plabs %>%
  mutate(Noise_Proc = factor(Noise_Proc, levels = noise_procs)) %>%
  dplyr::select(Noise_Proc, accuracy, balanced_accuracy, acc_p, bal_acc_p, acc_p_adj, bal_acc_p_adj) %>%
  arrange(Noise_Proc) %>%
  kable(.) %>%
  kable_styling(full_width=F)
```





### Deriving p-values using model-free shuffle null distributions -- CV inv prob

```{r}
if (!file.exists(paste0(rdata_path, "Combo_wise_10FCV_linear_SVM_e1071_inv_prob_pvals.Rds"))) {
  combo_wise_SVM_CV_inv_prob_pvals <- calc_empirical_nulls(class_res = combo_wise_SVM_CV_inv_prob,
                                                        null_data = model_free_shuffle_null_res,
                                                        grouping_var = "All")
  saveRDS(combo_wise_SVM_CV_inv_prob_pvals, file=paste0(rdata_path, "Combo_wise_10FCV_linear_SVM_e1071_inv_prob_pvals.Rds"))
  
} else {
  combo_wise_SVM_CV_inv_prob_pvals <- readRDS(paste0(rdata_path, "Combo_wise_10FCV_linear_SVM_e1071_inv_prob_pvals.Rds"))
}

combo_wise_SVM_CV_inv_prob_plabs <- combo_wise_SVM_CV_inv_prob_pvals %>%
  mutate(acc_p = scales::scientific(acc_p, digits = 3),
         bal_acc_p = scales::scientific(bal_acc_p, digits = 3),
         acc_p_adj = scales::scientific(acc_p_adj, digits = 3),
         bal_acc_p_adj = scales::scientific(bal_acc_p_adj, digits = 3))
```

Balanced accuracy:
```{r, fig.width=7, fig.height=5}
combo_wise_SVM_CV_inv_prob_pvals %>%
  ggplot(data=.) +
  geom_histogram(data = subset(model_free_shuffle_null_res, Type=="null"),
                 aes(x = balanced_accuracy, y=0.5*..density..), 
                 bins = 50,
                 alpha=0.6, position="identity",
                 fill = "gray70") +
  geom_vline(mapping=aes(xintercept = balanced_accuracy, color = Noise_Proc), size=1.2) +
  xlab("Balanced Accuracy from n=1,000,000 Model-Free Shuffles") +
  ylab("Scaled Density") +
  labs(color = "Noise Processing") +
  theme(strip.text.y.left = element_text(angle=0),
        strip.placement = "outside",
        legend.position = "bottom",
        legend.direction = "horizontal")
```

```{r, eval=F, echo=F}
# Save plot
ggsave("plots/Combo_Wise_Main_vs_Null_BAcc_10FCV_Linear_SVM_inv_prob.png",
       width=8, height=5, units="in", dpi=300)
```

Summary statistics:
```{r}
combo_wise_SVM_CV_inv_prob_plabs %>%
  mutate(Noise_Proc = factor(Noise_Proc, levels = noise_procs)) %>%
  arrange(Noise_Proc) %>%
  dplyr::select(Noise_Proc, accuracy, balanced_accuracy, acc_p, bal_acc_p, acc_p_adj, bal_acc_p_adj) %>%
  kable(.) %>%
  kable_styling(full_width=F)
```




### Deriving p-values using model-free shuffle null distributions -- CV SMOTE

```{r}
if (!file.exists(paste0(rdata_path, "Combo_wise_10FCV_linear_SVM_e1071_SMOTE_pvals.Rds"))) {
  combo_wise_SVM_CV_SMOTE_pvals <- calc_empirical_nulls(class_res = combo_wise_SVM_CV_SMOTE,
                                                        null_data = model_free_shuffle_null_res,
                                                        grouping_var = "All")
  saveRDS(combo_wise_SVM_CV_SMOTE_pvals, file=paste0(rdata_path, "Combo_wise_10FCV_linear_SVM_e1071_SMOTE_pvals.Rds"))
  
} else {
  combo_wise_SVM_CV_SMOTE_pvals <- readRDS(paste0(rdata_path, "Combo_wise_10FCV_linear_SVM_e1071_SMOTE_pvals.Rds"))
}

combo_wise_SVM_CV_SMOTE_plabs <- combo_wise_SVM_CV_SMOTE_pvals %>%
  mutate(acc_p = scales::scientific(acc_p, digits = 3),
         bal_acc_p = scales::scientific(bal_acc_p, digits = 3),
         acc_p_adj = scales::scientific(acc_p_adj, digits = 3),
         bal_acc_p_adj = scales::scientific(bal_acc_p_adj, digits = 3))
```

Balanced accuracy:
```{r, fig.width=7, fig.height=5}
combo_wise_SVM_CV_SMOTE_pvals %>%
  ggplot(data=.) +
  geom_histogram(data = subset(model_free_shuffle_null_res, Type=="null"),
                 aes(x = balanced_accuracy, y=0.5*..density..), 
                 bins = 50,
                 alpha=0.6, position="identity",
                 fill = "gray70") +
  geom_vline(mapping=aes(xintercept = balanced_accuracy, color = Noise_Proc), size=1.2) +
  xlab("Balanced Accuracy from n=1,000,000 Model-Free Shuffles") +
  ylab("Scaled Density") +
  labs(color = "Noise Processing") +
  theme(strip.text.y.left = element_text(angle=0),
        strip.placement = "outside",
        legend.position = "bottom",
        legend.direction = "horizontal")
```

```{r, eval=F, echo=F}
# Save plot
ggsave("plots/Combo_Wise_Main_vs_Null_BAcc_10FCV_Linear_SVM_SMOTE.png",
       width=8, height=5, units="in", dpi=300)
```

Summary statistics:
```{r}
combo_wise_SVM_CV_SMOTE_plabs %>%
  mutate(Noise_Proc = factor(Noise_Proc, levels = noise_procs)) %>%
  arrange(Noise_Proc) %>%
  dplyr::select(Noise_Proc, accuracy, balanced_accuracy, acc_p, bal_acc_p, acc_p_adj, bal_acc_p_adj) %>%
  kable(.) %>%
  kable_styling(full_width=F)
```

## Null model for overall accuracy

### AROMA+2P
Take the average of 1804 random accuracy values from the null distribution 10,000x and compare with the mean from AROMA+2P:

```{r}
set.seed(127)

if (!file.exists(paste0(rdata_path, "Combo_wise_meta_null_acc_AROMA_2P.Rds"))) {
  random_acc_list <- list()
  for (i in 1:10000) {
    random_acc <- model_free_shuffle_null_res %>%
      sample_n(1804) %>%
      summarise(mean_accuracy = mean(accuracy, na.rm=T),
                mean_balanced_accuracy = mean(balanced_accuracy, na.rm=T)) %>%
      mutate(Type="null")
    random_acc_list <- rlist::list.append(random_acc_list, random_acc)
  }
  random_1804_acc <- do.call(plyr::rbind.fill, random_acc_list)
  saveRDS(random_1804_acc, file=paste0(rdata_path, "Combo_wise_meta_null_acc_AROMA_2P.Rds"))
} else {
  random_1804_acc <- readRDS(paste0(rdata_path, "Combo_wise_meta_null_acc_AROMA_2P.Rds"))
}

real_1804_acc <- combo_wise_SVM_CV %>%
  filter(Noise_Proc=="AROMA+2P") %>%
  summarise(mean_accuracy = mean(accuracy, na.rm=T),
            mean_balanced_accuracy = mean(balanced_accuracy, na.rm=T)) %>%
  mutate(Type="main")

# Plot the accuracy
acc_p <- ggplot() +
  geom_histogram(data = random_1804_acc, mapping=aes(x=mean_accuracy), 
                 fill="gray70", bins=500) +
  geom_vline(data = real_1804_acc, mapping=aes(xintercept = mean_accuracy), color="red", size=1.2) +
  ylab("Number of Iterations") +
  xlab("Mean Accuracy") +
  ggtitle("Mean Accuracy in AROMA+2P Combo-Based Data") +
  theme(plot.title=element_text(hjust=0.5))

# Plot the balanced accuracy
bal_acc_p <- ggplot() +
  geom_histogram(data = random_1804_acc, mapping=aes(x=mean_balanced_accuracy), 
                 fill="gray70", bins=500) +
  geom_vline(data = real_1804_acc, mapping=aes(xintercept = mean_balanced_accuracy), color="red", size=1.2) +
  ylab("Number of Iterations") +
  xlab("Mean Balanced Accuracy") +
  ggtitle("Mean Balanced Accuracy in AROMA+2P Combo-Based Data") +
  theme(plot.title=element_text(hjust=0.5))

acc_p / bal_acc_p
ggsave("plots/Meta_Null_AROMA_2P_Combo_wise.png", width=7, height=8, units="in", dpi=300)
```

### AROMA+2P with inverse probability weighting 
Take the average of 22 random accuracy values from the null distribution 10,000x and compare with the mean from AROMA+2P with inverse probability weighting:

```{r}
set.seed(127)

if (!file.exists(paste0(rdata_path, "Combo_wise_meta_null_acc_AROMA_2P.Rds"))) {
  random_acc_list <- list()
  for (i in 1:10000) {
    random_acc <- model_free_shuffle_null_res %>%
      sample_n(1804) %>%
      summarise(mean_accuracy = mean(accuracy, na.rm=T),
                mean_balanced_accuracy = mean(balanced_accuracy, na.rm=T)) %>%
      mutate(Type="null")
    random_acc_list <- rlist::list.append(random_acc_list, random_acc)
  }
  random_1804_acc <- do.call(plyr::rbind.fill, random_acc_list)
  saveRDS(random_1804_acc, file=paste0(rdata_path, "Combo_wise_meta_null_acc_AROMA_2P.Rds"))
} else {
  random_1804_acc <- readRDS(paste0(rdata_path, "Combo_wise_meta_null_acc_AROMA_2P.Rds"))
}

real_1804_acc <- combo_wise_SVM_CV_inv_prob %>%
  filter(Noise_Proc=="AROMA+2P") %>%
  summarise(mean_accuracy = mean(accuracy, na.rm=T),
            mean_balanced_accuracy = mean(balanced_accuracy, na.rm=T)) %>%
  mutate(Type="main")

# Plot the accuracy
acc_p <- ggplot() +
  geom_histogram(data = random_1804_acc, mapping=aes(x=mean_accuracy), 
                 fill="gray70", bins=500) +
  geom_vline(data = real_1804_acc, mapping=aes(xintercept = mean_accuracy), 
             color="red", size=1.2) +
  ylab("Number of Iterations") +
  xlab("Mean Accuracy") +
  ggtitle("Mean Accuracy in AROMA+2P Combo-Based Data\nwith Inverse Probability Sample Weighting") +
  theme(plot.title=element_text(hjust=0.5))

# Plot the balanced accuracy
bal_acc_p <- ggplot() +
  geom_histogram(data = random_1804_acc, mapping=aes(x=mean_balanced_accuracy), 
                 fill="gray70", bins=500) +
  geom_vline(data = real_1804_acc, mapping=aes(xintercept = mean_balanced_accuracy),
             color="red", size=1.2) +
  ylab("Number of Iterations") +
  xlab("Mean Balanced Accuracy") +
  ggtitle("Mean Balanced Accuracy in AROMA+2P Combo-Based Data\nwith Inverse Probability Sample Weighting") +
  theme(plot.title=element_text(hjust=0.5))

acc_p / bal_acc_p
ggsave("plots/Meta_Null_AROMA_2P_Combo_wise_inv_prob.png", width=7, height=8, units="in", dpi=300)
```



### AROMA+2P with SMOTE
Take the average of 1,804 random accuracy values from the null distribution 10,000x and compare with the mean from AROMA+2P with inverse probability weighting:

```{r}
set.seed(127)

if (!file.exists(paste0(rdata_path, "Combo_wise_meta_null_acc_AROMA_2P.Rds"))) {
  random_acc_list <- list()
  for (i in 1:10000) {
    random_acc <- model_free_shuffle_null_res %>%
      sample_n(1804) %>%
      summarise(mean_accuracy = mean(accuracy, na.rm=T),
                mean_balanced_accuracy = mean(balanced_accuracy, na.rm=T)) %>%
      mutate(Type="null")
    random_acc_list <- rlist::list.append(random_acc_list, random_acc)
  }
  random_1804_acc <- do.call(plyr::rbind.fill, random_acc_list)
  saveRDS(random_1804_acc, file=paste0(rdata_path, "Combo_wise_meta_null_acc_AROMA_2P.Rds"))
} else {
  random_1804_acc <- readRDS(paste0(rdata_path, "Combo_wise_meta_null_acc_AROMA_2P.Rds"))
}

real_1804_acc <- combo_wise_SVM_CV_SMOTE %>%
  filter(Noise_Proc=="AROMA+2P") %>%
  summarise(mean_accuracy = mean(accuracy, na.rm=T),
            mean_balanced_accuracy = mean(balanced_accuracy, na.rm=T)) %>%
  mutate(Type="main")

# Plot the accuracy
acc_p <- ggplot() +
  geom_histogram(data = random_1804_acc, mapping=aes(x=mean_accuracy), 
                 fill="gray70", bins=500) +
  geom_vline(data = real_1804_acc, mapping=aes(xintercept = mean_accuracy), 
             color="red", size=1.2) +
  ylab("Number of Iterations") +
  xlab("Mean Accuracy") +
  ggtitle("Mean Accuracy in AROMA+2P Combo-Based Data\nwith SMOTE") +
  theme(plot.title=element_text(hjust=0.5))

# Plot the balanced accuracy
bal_acc_p <- ggplot() +
  geom_histogram(data = random_1804_acc, mapping=aes(x=mean_balanced_accuracy), 
                 fill="gray70", bins=500) +
  geom_vline(data = real_1804_acc, mapping=aes(xintercept = mean_balanced_accuracy),
             color="red", size=1.2) +
  ylab("Number of Iterations") +
  xlab("Mean Balanced Accuracy") +
  ggtitle("Mean Balanced Accuracy in AROMA+2P Combo-Based Data\nwith SMOTE") +
  theme(plot.title=element_text(hjust=0.5))

acc_p / bal_acc_p
ggsave("plots/Meta_Null_AROMA_2P_Combo_wise_SMOTE.png", width=7, height=8, units="in", dpi=300)
```

