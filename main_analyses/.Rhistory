if (svm_feature_var == "Feature") {
svm_feature_var_name = "names"
grouping_var_name = "Brain_Region"
grouping_var_vector <- unique(feature_matrix$Brain_Region)
} else if (svm_feature_var == "Brain_Region") {
svm_feature_var_name = svm_feature_var
grouping_var_name = "names"
grouping_var_vector <- unique(feature_matrix$names)
} else {
svm_feature_var_name = "Combo"
grouping_var_name = "Group_Var"
feature_matrix <- feature_matrix %>%
unite("Combo", c("Brain_Region", "names"), sep="_", remove=F)
grouping_var_vector <- c("All")
}
svm_feature_var = SVM_feature_var
if (svm_feature_var == "Feature") {
svm_feature_var_name = "names"
grouping_var_name = "Brain_Region"
grouping_var_vector <- unique(feature_matrix$Brain_Region)
} else if (svm_feature_var == "Brain_Region") {
svm_feature_var_name = svm_feature_var
grouping_var_name = "names"
grouping_var_vector <- unique(feature_matrix$names)
} else {
svm_feature_var_name = "Combo"
grouping_var_name = "Group_Var"
feature_matrix <- feature_matrix %>%
unite("Combo", c("Brain_Region", "names"), sep="_", remove=F)
grouping_var_vector <- c("All")
}
group_var = grouping_var_vector[1]
data_for_SVM <- subset(feature_matrix, get(grouping_var_name) == group_var) %>%
dplyr::ungroup() %>%
left_join(., sample_groups) %>%
dplyr::select(Sample_ID, Diagnosis, svm_feature_var_name, values) %>%
tidyr::pivot_wider(id_cols = c(Sample_ID, Diagnosis),
names_from = svm_feature_var_name,
values_from
= values) %>%
# Drop columns that are all NA/NAN
dplyr::select(where(function(x) any(!is.na(x)))) %>%
# Drop rows with NA for one or more column
drop_na()
# Otherwise iterate over each separate group
data_for_SVM <- subset(feature_matrix, get(grouping_var_name) == group_var) %>%
dplyr::ungroup() %>%
left_join(., sample_groups) %>%
dplyr::select(Sample_ID, Diagnosis, svm_feature_var_name, values)
View(data_for_SVM)
length(unique(data_for_SVM$Sample_ID))
# Otherwise iterate over each separate group
data_for_SVM <- subset(feature_matrix, get(grouping_var_name) == group_var) %>%
dplyr::ungroup() %>%
left_join(., sample_groups)
View(data_for_SVM)
data_for_SVM <- subset(feature_matrix, get(grouping_var_name) == group_var) %>%
dplyr::ungroup() %>%
left_join(., sample_groups) %>%
dplyr::select(Sample_ID, Diagnosis, svm_feature_var_name, values) %>%
tidyr::pivot_wider(id_cols = c(Sample_ID, Diagnosis),
names_from = svm_feature_var_name,
values_from
= values)
View(data_for_SVM)
data_for_SVM <- subset(feature_matrix, get(grouping_var_name) == group_var) %>%
dplyr::ungroup() %>%
left_join(., sample_groups) %>%
dplyr::select(Sample_ID, Diagnosis, svm_feature_var_name, values) %>%
distinct(.keep_all = T) %>%
tidyr::pivot_wider(id_cols = c(Sample_ID, Diagnosis),
names_from = svm_feature_var_name,
values_from
= values) %>%
# Drop columns that are all NA/NAN
dplyr::select(where(function(x) any(!is.na(x)))) %>%
# Drop rows with NA for one or more column
drop_na()
View(data_for_SVM)
# Pass data_for_SVM to in_sample_linear_SVM
SVM_results <- k_fold_CV_linear_SVM(input_data = data_for_SVM,
flds = flds,
k = num_k_folds,
svm_kernel = svm_kernel,
sample_wts = sample_wts,
shuffle_labels = shuffle_labels,
out_of_sample_only = out_of_sample_only) %>%
dplyr::mutate(grouping_var = group_var,
feature_set = feature_set,
Noise_Proc = noise_proc)
k_fold_CV_linear_SVM <- function(input_data,
flds = NULL,
k = k,
c = 1,
svm_kernel = "linear",
sample_wts = list("Control" = 1,
"Schz" = 1),
out_of_sample_only = TRUE,
shuffle_labels = FALSE) {
# Shuffle labels if specified
if (shuffle_labels) {
input_data <- transform(input_data, Diagnosis = sample(Diagnosis, replace = FALSE))
}
# Specify that Diagnosis is a factor so that createFolds creates stratified folds
input_data$Diagnosis <- factor(input_data$Diagnosis)
# Use pre-specified folds if passed in,
# Otherwise create train/test data folds
if (is.null(flds)) {
flds <- caret::createFolds(input_data$Diagnosis, k = k, list = TRUE, returnTrain = FALSE)
}
# Create dataframe to store subject IDs and whether or not they were properly classified
subject_classification_list <- list()
# Iterate over folds 1 through k
for (i in 1:k) {
# Define test and train data
test_i <- flds[[i]]
train_i <- setdiff(1:nrow(input_data), test_i)
# Training data
train_data <- input_data[train_i, ] %>%
filter(!is.na(Diagnosis))
train_subjects <- train_data$Sample_ID
train_data <- train_data %>% dplyr::select(-Sample_ID)
# Testing data
test_data <- input_data[test_i, ] %>%
filter(!is.na(Diagnosis))
test_subjects <- test_data$Sample_ID
test_data <- test_data %>% dplyr::select(-Sample_ID)
# Run linear SVM on fold
svmModel <- e1071::svm(factor(Diagnosis) ~ .,
kernel = svm_kernel,
cost = c,
data = train_data,
class.weights = sample_wts)
# Generate in-sample predictions based on SVM model
in_sample_pred <- predict(svmModel, train_data)
train_data$Diagnosis <- factor(train_data$Diagnosis, levels = levels(in_sample_pred))
# Create dataframe containing subject ID and whether out-of-sample prediction was correct
in_fold_predictions_by_subject <- data.frame(Sample_ID = train_subjects,
Sample_Type = "In-sample",
fold_number = i,
Actual_Diagnosis = train_data$Diagnosis,
Predicted_Diagnosis = in_sample_pred) %>%
mutate(Prediction_Correct = Actual_Diagnosis == Predicted_Diagnosis)
subject_classification_list <- append(subject_classification_list,
in_fold_predictions_by_subject)
# Generate out-of-sample predictions based on SVM model
out_sample_pred <- predict(svmModel, test_data)
test_data$Diagnosis <- factor(test_data$Diagnosis, levels = levels(out_sample_pred))
# Create dataframe containing subject ID and whether out-of-sample prediction was correct
out_fold_predictions_by_subject <- data.frame(Sample_ID = test_subjects,
Sample_Type = "Out-of-sample",
fold_number = i,
Actual_Diagnosis = test_data$Diagnosis,
Predicted_Diagnosis = out_sample_pred) %>%
mutate(Prediction_Correct = Actual_Diagnosis == Predicted_Diagnosis)
subject_classification_list <- append(subject_classification_list,
out_fold_predictions_by_subject)
}
# Compile classification res
classification_res <- do.call(plyr::rbind.fill, subject_classification_list)
# Subset to just out-of-sample data if requested
if (out_of_sample_only) {
classification_res <- classification_res %>%
filter(Sample_Type == "Out-of-sample")
}
# Return results
return(classification_res)
}
SVM_results <- k_fold_CV_linear_SVM(input_data = data_for_SVM,
flds = flds,
k = num_k_folds,
svm_kernel = svm_kernel,
sample_wts = sample_wts,
shuffle_labels = shuffle_labels,
out_of_sample_only = out_of_sample_only) %>%
dplyr::mutate(grouping_var = group_var,
feature_set = feature_set,
Noise_Proc = noise_proc)
input_data = data_for_SVM
k = num_k_folds
c = 1
# Specify that Diagnosis is a factor so that createFolds creates stratified folds
input_data$Diagnosis <- factor(input_data$Diagnosis)
# Create dataframe to store subject IDs and whether or not they were properly classified
subject_classification_list <- list()
i = 1
test_i <- flds[[i]]
train_i <- setdiff(1:nrow(input_data), test_i)
train_data <- input_data[train_i, ] %>%
filter(!is.na(Diagnosis))
train_subjects <- train_data$Sample_ID
train_data <- train_data %>% dplyr::select(-Sample_ID)
# Testing data
test_data <- input_data[test_i, ] %>%
filter(!is.na(Diagnosis))
test_subjects <- test_data$Sample_ID
test_data <- test_data %>% dplyr::select(-Sample_ID)
svmModel <- e1071::svm(factor(Diagnosis) ~ .,
kernel = svm_kernel,
cost = c,
data = train_data,
class.weights = sample_wts)
in_sample_pred <- predict(svmModel, train_data)
train_data$Diagnosis <- factor(train_data$Diagnosis, levels = levels(in_sample_pred))
# Create dataframe containing subject ID and whether out-of-sample prediction was correct
in_fold_predictions_by_subject <- data.frame(Sample_ID = train_subjects,
Sample_Type = "In-sample",
fold_number = i,
Actual_Diagnosis = train_data$Diagnosis,
Predicted_Diagnosis = in_sample_pred) %>%
mutate(Prediction_Correct = Actual_Diagnosis == Predicted_Diagnosis)
subject_classification_list <- append(subject_classification_list,
in_fold_predictions_by_subject)
out_sample_pred <- predict(svmModel, test_data)
test_data$Diagnosis <- factor(test_data$Diagnosis, levels = levels(out_sample_pred))
# Create dataframe containing subject ID and whether out-of-sample prediction was correct
out_fold_predictions_by_subject <- data.frame(Sample_ID = test_subjects,
Sample_Type = "Out-of-sample",
fold_number = i,
Actual_Diagnosis = test_data$Diagnosis,
Predicted_Diagnosis = out_sample_pred) %>%
mutate(Prediction_Correct = Actual_Diagnosis == Predicted_Diagnosis)
subject_classification_list <- append(subject_classification_list,
out_fold_predictions_by_subject)
# Compile classification res
classification_res <- do.call(plyr::rbind.fill, subject_classification_list)
subject_classification_list[[1]]
View(subject_classification_list)
subject_classification_df = as.data.frame(subject_classification_list)
subject_classification_list <- vector()
subject_classification_list <- c(subject_classification_list,
out_fold_predictions_by_subject)
list.append <- function (.data, ...)
{
if (is.list(.data)) {
c(.data, list(...))
}
else {
c(.data, ..., recursive = FALSE)
}
}
subject_classification_list <- list()
subject_classification_list <- list.append(subject_classification_list,
out_fold_predictions_by_subject)
# Compile classification res
classification_res <- do.call(plyr::rbind.fill, subject_classification_list)
source("~/github/fMRI_FeaturesDisorders/helper_functions/Linear_SVM.R")
# Pass data_for_SVM to in_sample_linear_SVM
SVM_results <- k_fold_CV_linear_SVM(input_data = data_for_SVM,
flds = flds,
k = num_k_folds,
svm_kernel = svm_kernel,
sample_wts = sample_wts,
shuffle_labels = shuffle_labels,
out_of_sample_only = out_of_sample_only) %>%
dplyr::mutate(grouping_var = group_var,
feature_set = feature_set,
Noise_Proc = noise_proc)
group_wise_SVM_CV_weighting <- run_univariate_cv_svm_by_input_var(data_path = data_path,
dataset_ID = dataset_ID,
feature_set = univariate_feature_set,
test_package = test_package,
svm_kernel = kernel,
grouping_var = grouping_var,
flds = sample_folds,
svm_feature_var = SVM_feature_var,
out_of_sample_only = TRUE,
use_inv_prob_weighting = use_inv_prob_weighting,
noise_procs = noise_procs)
group_wise_SVM_CV_weighting <- run_univariate_cv_svm_by_input_var(data_path = data_path,
dataset_ID = dataset_ID,
feature_set = univariate_feature_set,
svm_kernel = kernel,
grouping_var = grouping_var,
flds = sample_folds,
svm_feature_var = SVM_feature_var,
out_of_sample_only = TRUE,
use_inv_prob_weighting = use_inv_prob_weighting,
noise_procs = noise_procs)
kernel = "linear"
group_wise_SVM_CV_weighting <- run_univariate_cv_svm_by_input_var(data_path = data_path,
dataset_ID = dataset_ID,
feature_set = univariate_feature_set,
svm_kernel = kernel,
grouping_var = grouping_var,
flds = sample_folds,
svm_feature_var = SVM_feature_var,
out_of_sample_only = TRUE,
use_inv_prob_weighting = use_inv_prob_weighting,
noise_procs = noise_procs)
saveRDS(group_wise_SVM_CV_weighting, file=paste0(rdata_path,
sprintf("%s_wise_CV_linear_SVM_%s_%s.Rds",
grouping_type,
univariate_feature_set,
weighting_name)))
group_wise_SVM_balanced_accuracy <- group_wise_SVM_CV_weighting %>%
group_by(grouping_var, Noise_Proc, Sample_Type) %>%
summarise(accuracy = sum(Prediction_Correct) / n(),
balanced_accuracy = caret::confusionMatrix(data = Predicted_Diagnosis,
reference = Actual_Diagnosis)$byClass[["Balanced Accuracy"]])
saveRDS(group_wise_SVM_balanced_accuracy, file=paste0(rdata_path, sprintf("%s_wise_CV_linear_SVM_%s_%s_balacc.Rds",
grouping_type,
univariate_feature_set,
weighting_name)))
View(group_wise_SVM_balanced_accuracy)
length(unique(group_wise_SVM_CV_weighting$Sample_ID))
univariate_feature_set <- "catch22"
pairwise_feature_set <- "pyspi_19"
subject_csv <- "participants.csv"
github_dir <- "/headnode1/abry4213/github/fMRI_FeaturesDisorders/"
rdata_path <- "/headnode1/abry4213/data/UCLA_Schizophrenia/Rdata/"
data_path <- "/headnode1/abry4213/data/UCLA_Schizophrenia/"
dataset_ID <- "UCLA_Schizophrenia"
noise_procs <- c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")
plot_dir <- paste0(data_path, "plots/")
icesTAF::mkdir(plot_dir)
# Set the seed
set.seed(127)
# Load tidyverse
library(tidyverse)
subjects_to_use <- read.csv(paste0(data_path, sprintf("%s_samples_with_univariate_%s_and_pairwise_%s.csv",
dataset_ID,
univariate_feature_set,
pairwise_feature_set)))
if (!file.exists(paste0(rdata_path, dataset_ID, "_samples_per_10_folds.Rds"))) {
# Make folds
set.seed(127)
k = 10
sample_folds <- caret::createFolds(subjects_to_use$group, k = k, list = TRUE, returnTrain = FALSE)
# Save to Rds file
saveRDS(sample_folds, file=paste0(rdata_path, dataset_ID, "_samples_per_10_folds.Rds"))
} else {
sample_folds <- readRDS(paste0(rdata_path, dataset_ID, "_samples_per_10_folds.Rds"))
}
grouping_param_df <- data.frame(grouping_type = c("ROI", "Feature", "Combo"),
grouping_var = c("Brain_Region", "Feature", "Combo"),
SVM_feature_var = c("Feature", "Brain_Region", "Combo"))
weighting_param_df <- data.frame(name = c("inv_prob"),
use_inv_prob_weighting = c(TRUE))
# Use a linear kernel
kernel = "linear"
i=3
j=1
grouping_type = grouping_param_df$grouping_type[i]
grouping_var = grouping_param_df$grouping_var[i]
SVM_feature_var = grouping_param_df$SVM_feature_var[i]
weighting_name <- weighting_param_df$name[j]
use_inv_prob_weighting <- weighting_param_df$use_inv_prob_weighting[j]
group_wise_SVM_CV_weighting <- run_univariate_cv_svm_by_input_var(data_path = data_path,
dataset_ID = dataset_ID,
feature_set = univariate_feature_set,
svm_kernel = kernel,
grouping_var = grouping_var,
flds = sample_folds,
svm_feature_var = SVM_feature_var,
out_of_sample_only = TRUE,
use_inv_prob_weighting = use_inv_prob_weighting,
noise_procs = noise_procs)
source("~/github/fMRI_FeaturesDisorders/helper_functions/Linear_SVM.R")
group_wise_SVM_CV_weighting <- run_univariate_cv_svm_by_input_var(data_path = data_path,
dataset_ID = dataset_ID,
feature_set = univariate_feature_set,
svm_kernel = kernel,
grouping_var = grouping_var,
flds = sample_folds,
svm_feature_var = SVM_feature_var,
out_of_sample_only = TRUE,
use_inv_prob_weighting = use_inv_prob_weighting,
noise_procs = noise_procs)
flds = sample_folds
eature_set = univariate_feature_set
ut_of_sample_only = TRUE
out_of_sample_only = TRUE
svm_feature_var = SVM_feature_var
rdata_path <- paste0(data_path, "Rdata/")
# Get control/schz proportions
sample_groups <- read.csv(paste0(data_path, sprintf("%s_samples_with_univariate_%s.csv",
dataset_ID, univariate_feature_set))) %>%
dplyr::select(Sample_ID, Diagnosis)
# Define sample weights
# Default is 1 and 1 if use_inv_prob_weighting is not included
if (use_inv_prob_weighting) {
# Convert to sample weights based on inverse of probability
sample_wts <- as.list(1/prop.table(table(sample_groups$Diagnosis)))
} else {
sample_wts <- as.list(rep(1, length(unique(sample_groups$Diagnosis))))
names(sample_wts) = unique(sample_groups$Diagnosis)
}
class_res_list <- list()
noise_proc = "AROMA+2P"
# Clean up names
noise_label <- gsub("\\+", "_", noise_proc)
feature_matrix <- readRDS(paste0(rdata_path, sprintf("%s_%s_filtered_zscored.Rds",
dataset_ID,
univariate_feature_set))) %>%
dplyr::filter(Noise_Proc == noise_proc)
if (svm_feature_var == "Feature") {
svm_feature_var_name = "names"
grouping_var_name = "Brain_Region"
grouping_var_vector <- unique(feature_matrix$Brain_Region)
} else if (svm_feature_var == "Brain_Region") {
svm_feature_var_name = svm_feature_var
grouping_var_name = "names"
grouping_var_vector <- unique(feature_matrix$names)
} else {
svm_feature_var_name = "Combo"
grouping_var_name = "Group_Var"
feature_matrix <- feature_matrix %>%
unite("Combo", c("Brain_Region", "names"), sep="_", remove=F)
grouping_var_vector <- c("All")
}
data_for_SVM <- feature_matrix %>%
left_join(., sample_groups) %>%
dplyr::select(Sample_ID, Diagnosis, Combo, values) %>%
tidyr::pivot_wider(id_cols = c(Sample_ID, Diagnosis),
names_from = Combo,
values_from
= values) %>%
# Drop columns that are all NA/NAN
dplyr::select(where(function(x) any(!is.na(x)))) %>%
# Drop rows with NA for one or more column
drop_na()
data_for_SVM <- feature_matrix %>%
left_join(., sample_groups) %>%
dplyr::select(Sample_ID, Diagnosis, Combo, values) %>%
distinct(.keep_all = T) %>%
tidyr::pivot_wider(id_cols = c(Sample_ID, Diagnosis),
names_from = Combo,
values_from
= values) %>%
# Drop columns that are all NA/NAN
dplyr::select(where(function(x) any(!is.na(x)))) %>%
# Drop rows with NA for one or more column
drop_na()
SVM_results <- k_fold_CV_linear_SVM(input_data = data_for_SVM,
flds = flds,
k = num_k_folds,
svm_kernel = svm_kernel,
sample_wts = sample_wts,
shuffle_labels = shuffle_labels,
out_of_sample_only = out_of_sample_only) %>%
dplyr::mutate(grouping_var = group_var,
feature_set = feature_set,
Noise_Proc = noise_proc)
shuffle_labels = F
SVM_results <- k_fold_CV_linear_SVM(input_data = data_for_SVM,
flds = flds,
k = num_k_folds,
svm_kernel = svm_kernel,
sample_wts = sample_wts,
shuffle_labels = shuffle_labels,
out_of_sample_only = out_of_sample_only) %>%
dplyr::mutate(grouping_var = group_var,
feature_set = feature_set,
Noise_Proc = noise_proc)
num_k_folds = 10
SVM_results <- k_fold_CV_linear_SVM(input_data = data_for_SVM,
flds = flds,
k = num_k_folds,
svm_kernel = svm_kernel,
sample_wts = sample_wts,
shuffle_labels = shuffle_labels,
out_of_sample_only = out_of_sample_only) %>%
dplyr::mutate(grouping_var = group_var,
feature_set = feature_set,
Noise_Proc = noise_proc)
svm_kernel = "linear"
SVM_results <- k_fold_CV_linear_SVM(input_data = data_for_SVM,
flds = flds,
k = num_k_folds,
svm_kernel = svm_kernel,
sample_wts = sample_wts,
shuffle_labels = shuffle_labels,
out_of_sample_only = out_of_sample_only) %>%
dplyr::mutate(grouping_var = group_var,
feature_set = feature_set,
Noise_Proc = noise_proc)
SVM_results <- k_fold_CV_linear_SVM(input_data = data_for_SVM,
flds = flds,
k = num_k_folds,
svm_kernel = svm_kernel,
sample_wts = sample_wts,
shuffle_labels = shuffle_labels,
out_of_sample_only = out_of_sample_only) %>%
dplyr::mutate(grouping_var = group_var,
feature_set = feature_set,
Noise_Proc = noise_proc)
source("~/github/fMRI_FeaturesDisorders/helper_functions/Linear_SVM.R")
group_wise_SVM_CV_weighting <- run_univariate_cv_svm_by_input_var(data_path = data_path,
dataset_ID = dataset_ID,
feature_set = univariate_feature_set,
svm_kernel = kernel,
grouping_var = grouping_var,
flds = sample_folds,
svm_feature_var = SVM_feature_var,
out_of_sample_only = TRUE,
use_inv_prob_weighting = use_inv_prob_weighting,
noise_procs = noise_procs)
saveRDS(group_wise_SVM_CV_weighting, file=paste0(rdata_path,
sprintf("%s_wise_CV_linear_SVM_%s_%s.Rds",
grouping_type,
univariate_feature_set,
weighting_name)))
group_wise_SVM_balanced_accuracy <- group_wise_SVM_CV_weighting %>%
group_by(grouping_var, Noise_Proc, Sample_Type) %>%
summarise(accuracy = sum(Prediction_Correct) / n(),
balanced_accuracy = caret::confusionMatrix(data = Predicted_Diagnosis,
reference = Actual_Diagnosis)$byClass[["Balanced Accuracy"]])
saveRDS(group_wise_SVM_balanced_accuracy, file=paste0(rdata_path, sprintf("%s_wise_CV_linear_SVM_%s_%s_balacc.Rds",
grouping_type,
univariate_feature_set,
weighting_name)))
