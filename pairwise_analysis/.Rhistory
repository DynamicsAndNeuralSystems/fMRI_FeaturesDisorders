# Run command if null file doesn't exist
if (!file.exists(sprintf("%s/%s_wise_%s_%s_null_model_fit_iter_%s.Rds",
output_data_dir, grouping_var, univariate_feature_set,
weighting_name, p))) {
cat("\nNow creating pbs script for for iteration", p, "\n")
new_pbs_file <- readLines(template_pbs_file)
# Replace file paths
pbs_text_replaced <- mgsub::mgsub(new_pbs_file,
to_be_replaced,
replacement_values)
# Replace null iteration number
pbs_text_replaced <- gsub("iterj", p, pbs_text_replaced)
# Write updated PBS script to file
output_pbs_file <- writeLines(pbs_text_replaced,
paste0(output_scripts_dir,
"null_iter_", p, ".pbs"))
}
}
}
}
rdata_path <- "/headnode1/abry4213/data/ABIDE_ASD/Rdata/"
data_path <- "/headnode1/abry4213/data/ABIDE_ASD/"
dataset_ID <- "ABIDE_ASD"
noise_procs <- c("FC1000")
noise_proc_for_null <- "FC1000"
subjects_to_use <- readRDS(paste0(data_path, sprintf("%s_samples_with_univariate_%s_and_pairwise_%s.Rds",
dataset_ID,
univariate_feature_set,
pairwise_feature_set)))
if (!file.exists(paste0(rdata_path, dataset_ID, "_samples_per_10_folds.Rds"))) {
# Make folds
set.seed(127)
k = 10
sample_folds <- caret::createFolds(subjects_to_use$Diagnosis, k = k, list = TRUE, returnTrain = FALSE)
# Save to Rds file
saveRDS(sample_folds, file=paste0(rdata_path, dataset_ID, "_samples_per_10_folds.Rds"))
} else {
sample_folds <- readRDS(paste0(rdata_path, dataset_ID, "_samples_per_10_folds.Rds"))
}
for (i in 1:nrow(grouping_param_df)) {
grouping_type = grouping_param_df$grouping_type[i]
grouping_var = grouping_param_df$grouping_var[i]
SVM_feature_var = grouping_param_df$SVM_feature_var[i]
#### 10-fold linear SVM with different weights
# Iterate over weighting_param_df
for (j in 1:nrow(weighting_param_df)) {
weighting_name <- weighting_param_df$name[j]
use_inv_prob_weighting <- weighting_param_df$use_inv_prob_weighting[j]
# Run given weighting for 10-fold CV linear SVM
if (!file.exists(paste0(rdata_path, sprintf("%s_wise_CV_linear_SVM_%s_%s.Rds",
grouping_type,
univariate_feature_set,
weighting_name)))) {
group_wise_SVM_CV_weighting <- run_univariate_cv_svm_by_input_var(data_path = data_path,
dataset_ID = dataset_ID,
univariate_feature_set = univariate_feature_set,
pairwise_feature_set = pairwise_feature_set,
svm_kernel = kernel,
grouping_var = grouping_var,
flds = sample_folds,
svm_feature_var = SVM_feature_var,
out_of_sample_only = TRUE,
use_inv_prob_weighting = use_inv_prob_weighting,
noise_procs = noise_procs)
saveRDS(group_wise_SVM_CV_weighting, file=paste0(rdata_path,
sprintf("%s_wise_CV_linear_SVM_%s_%s.Rds",
grouping_type,
univariate_feature_set,
weighting_name)))
} else {
group_wise_SVM_CV_weighting <- readRDS(paste0(rdata_path,
sprintf("%s_wise_CV_linear_SVM_%s_%s.Rds",
grouping_type,
univariate_feature_set,
weighting_name)))
}
#### Calculate balanced accuracy across all folds
if (!file.exists(paste0(rdata_path, sprintf("%s_wise_CV_linear_SVM_%s_%s_balacc.Rds",
grouping_type,
univariate_feature_set,
weighting_name)))) {
group_wise_SVM_balanced_accuracy <- group_wise_SVM_CV_weighting %>%
group_by(grouping_var, Noise_Proc, Sample_Type) %>%
summarise(accuracy = sum(Prediction_Correct) / n(),
balanced_accuracy = caret::confusionMatrix(data = Predicted_Diagnosis,
reference = Actual_Diagnosis)$byClass[["Balanced Accuracy"]])
saveRDS(group_wise_SVM_balanced_accuracy, file=paste0(rdata_path, sprintf("%s_wise_CV_linear_SVM_%s_%s_balacc.Rds",
grouping_type,
univariate_feature_set,
weighting_name)))
} else {
group_wise_SVM_balanced_accuracy <- readRDS(paste0(rdata_path, sprintf("%s_wise_CV_linear_SVM_%s_%s_balacc.Rds",
grouping_type,
univariate_feature_set,
weighting_name)))
}
############################################################################
# Null model fits
############################################################################
# We want to run 1,000 null model fits, and we can run 10 permutations per iteration
num_permutations <- 100
nperm_per_iter <- 10
wall_hrs <- "12"
# Use 10-fold cross-validation
num_k_folds <- 10
# Define the univariate template PBS script
template_pbs_file <- paste0(github_dir, "helper_functions/classification/template_univariate_null_model_fit.pbs")
# Where to store null model fit results
output_data_dir <- paste0(rdata_path, sprintf("%s_%s_wise_%s_%s_null_model_fits/",
dataset_ID,
grouping_type,
univariate_feature_set,
weighting_name))
# Where to save PBS script to
output_scripts_dir <- paste0(github_dir, sprintf("univariate_analysis/%s_%s_wise_%s_%s_null_model_fits/",
dataset_ID,
grouping_type,
univariate_feature_set,
weighting_name))
# Make these directories
icesTAF::mkdir(output_data_dir)
icesTAF::mkdir(output_scripts_dir)
# Lookup table for PBS script
lookup_list <- list("NAME" = sprintf("univariate_%s_wise_null_model_fit",
grouping_type),
"MEMNUM" = "20",
"NCPUS" = "1",
"DATASET_ID" = dataset_ID,
"GITHUB_DIR" = github_dir,
"DATA_PATH" = data_path,
"EMAIL" = "abry4213@uni.sydney.edu.au",
"PBS_NOTIFY" = "a",
"WALL_HRS" = wall_hrs,
"NOISE_PROCS" = noise_proc_for_null,
"NUM_K_FOLDS" = num_k_folds,
"NUM_PERMS_PER_ITER" = nperm_per_iter,
"OUTPUT_DATA_DIR" = output_data_dir,
"UNIVARIATE_FEATURE_SET" = univariate_feature_set,
"PAIRWISE_FEATURE_SET" = pairwise_feature_set,
"GROUPING_VAR" = grouping_var,
"SVM_FEATURE_VAR" = SVM_feature_var,
"WEIGHTING_NAME" = weighting_name)
to_be_replaced <- names(lookup_list)
replacement_values <- unlist(unname(lookup_list))
# Create a PBS script per iteration
for (p in 1:num_permutations) {
# Run command if null file doesn't exist
if (!file.exists(sprintf("%s/%s_wise_%s_%s_null_model_fit_iter_%s.Rds",
output_data_dir, grouping_var, univariate_feature_set,
weighting_name, p))) {
cat("\nNow creating pbs script for for iteration", p, "\n")
new_pbs_file <- readLines(template_pbs_file)
# Replace file paths
pbs_text_replaced <- mgsub::mgsub(new_pbs_file,
to_be_replaced,
replacement_values)
# Replace null iteration number
pbs_text_replaced <- gsub("iterj", p, pbs_text_replaced)
# Write updated PBS script to file
output_pbs_file <- writeLines(pbs_text_replaced,
paste0(output_scripts_dir,
"null_iter_", p, ".pbs"))
}
}
}
}
group_wise_SVM_CV_weighting <- run_pairwise_cv_svm_by_input_var(pyspi_data = pyspi_data,
data_path = data_path,
SPI_directionality = SPI_directionality,
svm_kernel = "linear",
num_k_folds = 10,
flds = sample_folds,
grouping_var = grouping_var,
svm_feature_var = SVM_feature_var,
noise_proc = noise_proc_for_null,
use_inv_prob_weighting = use_inv_prob_weighting,
shuffle_labels = FALSE)
gc()
univariate_feature_set <- "catch22"
pairwise_feature_set <- "pyspi_19"
subject_csv <- "participants.csv"
github_dir <- "/headnode1/abry4213/github/fMRI_FeaturesDisorders/"
rdata_path <- "/headnode1/abry4213/data/UCLA_Schizophrenia/Rdata/"
pydata_path <- "/headnode1/abry4213/data/UCLA_Schizophrenia/pydata/"
data_path <- "/headnode1/abry4213/data/UCLA_Schizophrenia/"
dataset_ID <- "UCLA_Schizophrenia"
noise_procs <- c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")
noise_proc_for_null <- "AROMA+2P+GMR"
set.seed(127)
# Load tidyverse
library(tidyverse)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
helper_script_dir = "../helper_functions/classification/"
source(paste0(helper_script_dir, "Linear_SVM.R"))
source(paste0(helper_script_dir, "Null_distributions.R"))
pyspi_data_file <- sprintf("%s/%s_pairwise_%s.Rds",
pydata_path, dataset_ID, pairwise_feature_set)
pyspi_data <- readRDS(pyspi_data_file) %>%
dplyr::filter(Noise_Proc %in% noise_proc_for_null) %>%
dplyr::mutate(Diagnosis = stringr::str_to_sentence(Diagnosis))
SPI_directionality <- read.csv(paste0(github_dir, "pairwise_analysis/SPI_Direction_Info.csv"))
weighting_param_df <- data.frame(name = c("inv_prob"),
use_inv_prob_weighting = c(TRUE))
SVM_grouping_params <- data.frame(grouping_var = c("SPI"),
SVM_feature_var = c("region_pair"))
i=1
j=1
grouping_var = SVM_grouping_params$grouping_var[i]
SVM_feature_var = SVM_grouping_params$SVM_feature_var[i]
weighting_name <- weighting_param_df$name[j]
use_inv_prob_weighting <- weighting_param_df$use_inv_prob_weighting[j]
svm_kernel = "linear"
num_k_folds = 10
subjects_to_use <- readRDS(paste0(data_path, sprintf("%s_samples_with_univariate_%s_and_pairwise_%s.Rds",
dataset_ID,
univariate_feature_set,
pairwise_feature_set)))
if (!file.exists(paste0(rdata_path, dataset_ID, "_samples_per_10_folds.Rds"))) {
# Make folds
set.seed(127)
k = 10
sample_folds <- caret::createFolds(subjects_to_use$Diagnosis, k = k, list = TRUE, returnTrain = FALSE)
# Save to Rds file
saveRDS(sample_folds, file=paste0(rdata_path, dataset_ID, "_samples_per_10_folds.Rds"))
} else {
sample_folds <- readRDS(paste0(rdata_path, dataset_ID, "_samples_per_10_folds.Rds"))
}
flds = sample_folds
svm_feature_var = SVM_feature_var
noise_proc = noise_proc_for_null
shuffle_labels = FALSE
rdata_path <- paste0(data_path, "Rdata/")
# Get diagnosis proportions
sample_groups <- readRDS(paste0(data_path, sprintf("%s_samples_with_univariate_%s_and_pairwise_%s.Rds",
dataset_ID,
univariate_feature_set,
pairwise_feature_set))) %>%
dplyr::select(Sample_ID, Diagnosis)
# Define sample weights
# Default is 1 and 1 if use_inv_prob_weighting is not included
if (use_inv_prob_weighting) {
# Convert to sample weights based on inverse of probability
sample_wts <- as.list(1/prop.table(table(sample_groups$Diagnosis)))
} else {
sample_wts <- as.list(rep(1, length(unique(sample_groups$Diagnosis))))
names(sample_wts) = unique(sample_groups$Diagnosis)
}
# Initialize results list for SVM
class_res_list <- list()
if (svm_feature_var == "region_pair") {
svm_feature_var_name = svm_feature_var
grouping_var_name = "SPI"
grouping_var_vector <- unique(pyspi_data$SPI)
# Filter by directionality
pyspi_data <- pyspi_data %>%
dplyr::rename("group_SPI" = "SPI") %>%
group_by(group_SPI) %>%
mutate(Direction = SPI_directionality %>%
filter(SPI == unique(group_SPI)) %>%
distinct(Direction) %>%
pull(Direction)) %>%
dplyr::rename("SPI" = "group_SPI") %>%
mutate(region_pair = case_when(Direction == "Undirected" ~ ifelse(brain_region_1 < brain_region_2,
paste0(brain_region_1, "_", brain_region_2),
paste0(brain_region_2, "_", brain_region_1)),
Direction == "Directed" ~ paste0(brain_region_1, "_", brain_region_2))) %>%
dplyr::select(-brain_region_1, -brain_region_2)  %>%
distinct(Sample_ID, SPI, region_pair, .keep_all = T)
} else if (svm_feature_var == "SPI") {
# Don't want to filter by directionality
pyspi_data <- pyspi_data %>%
rowwise() %>%
tidyr::unite("region_pair", c(brain_region_1, brain_region_2), sep="_") %>%
distinct(Sample_ID, SPI, region_pair, .keep_all = T)
svm_feature_var_name = svm_feature_var
grouping_var_name = "region_pair"
grouping_var_vector <- unique(pyspi_data$region_pair)
} else {
svm_feature_var_name = "Combo"
grouping_var_name = "Group_Var"
# Filter by directionality
pyspi_data <- pyspi_data %>%
# Special cases
filter(SPI != "sgc_nonparametric_mean_fs-1_fmin-0_fmax-0-5",
!(Sample_ID == "sub-10171" & SPI == "di_gaussian")) %>%
rowwise() %>%
tidyr::unite("region_pair", c(brain_region_1, brain_region_2), sep="_") %>%
distinct(Sample_ID, SPI, region_pair, .keep_all = T) %>%
group_by(SPI, region_pair) %>%
filter(!all(is.na(value))) %>%
dplyr::select(where(function(x) any(!is.na(x)))) %>%
unite("Combo", c("region_pair", "SPI"), sep="_", remove=F)
grouping_var_vector <- c("All")
}
group_var = unique(grouping_var_vector)[1]
data_for_SVM <- subset(pyspi_data, get(grouping_var_name) == group_var) %>%
dplyr::ungroup() %>%
dplyr::select(Sample_ID, group, svm_feature_var_name, value) %>%
tidyr::pivot_wider(id_cols = c(Sample_ID, Diagnosis),
names_from = svm_feature_var_name,
values_from
= value) %>%
# Drop columns that are all NA/NAN
dplyr::select(where(function(x) any(!is.na(x)))) %>%
# Drop rows with NA for one or more column
drop_na()
data_for_SVM <- subset(pyspi_data, get(grouping_var_name) == group_var) %>%
dplyr::ungroup() %>%
dplyr::select(Sample_ID, Diagnosis, svm_feature_var_name, value) %>%
tidyr::pivot_wider(id_cols = c(Sample_ID, Diagnosis),
names_from = svm_feature_var_name,
values_from
= value) %>%
# Drop columns that are all NA/NAN
dplyr::select(where(function(x) any(!is.na(x)))) %>%
# Drop rows with NA for one or more column
drop_na()
if (nrow(data_for_SVM) > 0) {
# Run k-fold linear SVM
SVM_results <- k_fold_CV_linear_SVM(input_data = data_for_SVM,
flds = flds,
k = num_k_folds,
svm_kernel = svm_kernel,
sample_wts = sample_wts,
shuffle_labels = shuffle_labels,
out_of_sample_only = out_of_sample_only) %>%
dplyr::mutate(grouping_var = group_var,
feature_set = feature_set,
use_inv_prob_weighting = use_inv_prob_weighting,
Noise_Proc = noise_proc)
# Append results to list
class_res_list <- list.append(class_res_list, SVM_results)
} else {
cat("\nNo observations available for", group_var, "after filtering.\n")
}
out_of_sample_only = TRUE
SVM_results <- k_fold_CV_linear_SVM(input_data = data_for_SVM,
flds = flds,
k = num_k_folds,
svm_kernel = svm_kernel,
sample_wts = sample_wts,
shuffle_labels = shuffle_labels,
out_of_sample_only = out_of_sample_only) %>%
dplyr::mutate(grouping_var = group_var,
feature_set = feature_set,
use_inv_prob_weighting = use_inv_prob_weighting,
Noise_Proc = noise_proc)
SVM_results <- k_fold_CV_linear_SVM(input_data = data_for_SVM,
flds = flds,
k = num_k_folds,
svm_kernel = svm_kernel,
sample_wts = sample_wts,
shuffle_labels = shuffle_labels,
out_of_sample_only = out_of_sample_only) %>%
dplyr::mutate(grouping_var = group_var,
pairwise_feature_set = pairwise_feature_set,
use_inv_prob_weighting = use_inv_prob_weighting,
Noise_Proc = noise_proc)
View(SVM_results)
source("~/github/fMRI_FeaturesDisorders/helper_functions/classification/Linear_SVM.R")
tryCatch({group_wise_SVM_CV_weighting <- run_pairwise_cv_svm_by_input_var(pyspi_data = pyspi_data,
data_path = data_path,
SPI_directionality = SPI_directionality,
svm_kernel = "linear",
num_k_folds = 10,
flds = sample_folds,
grouping_var = grouping_var,
svm_feature_var = SVM_feature_var,
noise_proc = noise_proc_for_null,
out_of_sample_only = TRUE,
use_inv_prob_weighting = use_inv_prob_weighting,
shuffle_labels = FALSE)
saveRDS(group_wise_SVM_CV_weighting, file=paste0(rdata_path,
sprintf("%s_pairwise_CV_linear_SVM_%s_%s.Rds",
grouping_var,
pairwise_feature_set,
weighting_name)))
}, error = function(e) {
cat("Could not run linear SVM for", grouping_var, pairwise_feature_set, ".\n")
message(e)
})
rdata_path <- paste0(data_path, "Rdata/")
# Get diagnosis proportions
sample_groups <- readRDS(paste0(data_path, sprintf("%s_samples_with_univariate_%s_and_pairwise_%s.Rds",
dataset_ID,
univariate_feature_set,
pairwise_feature_set))) %>%
dplyr::select(Sample_ID, Diagnosis)
# Define sample weights
# Default is 1 and 1 if use_inv_prob_weighting is not included
if (use_inv_prob_weighting) {
# Convert to sample weights based on inverse of probability
sample_wts <- as.list(1/prop.table(table(sample_groups$Diagnosis)))
} else {
sample_wts <- as.list(rep(1, length(unique(sample_groups$Diagnosis))))
names(sample_wts) = unique(sample_groups$Diagnosis)
}
# Initialize results list for SVM
class_res_list <- list()
pyspi_data_file <- sprintf("%s/%s_pairwise_%s.Rds",
pydata_path, dataset_ID, pairwise_feature_set)
pyspi_data <- readRDS(pyspi_data_file) %>%
dplyr::filter(Noise_Proc %in% noise_proc_for_null) %>%
dplyr::mutate(Diagnosis = stringr::str_to_sentence(Diagnosis))
SPI_directionality <- read.csv(paste0(github_dir, "pairwise_analysis/SPI_Direction_Info.csv"))
source("~/github/fMRI_FeaturesDisorders/helper_functions/classification/Linear_SVM.R")
pairwise_data = pyspi_data
svm_feature_var_name = svm_feature_var
grouping_var_name = "SPI"
grouping_var_vector <- unique(pairwise_data$SPI)
# Filter by directionality
pairwise_data <- pairwise_data %>%
dplyr::rename("group_SPI" = "SPI") %>%
group_by(group_SPI) %>%
mutate(Direction = SPI_directionality %>%
filter(SPI == unique(group_SPI)) %>%
distinct(Direction) %>%
pull(Direction)) %>%
dplyr::rename("SPI" = "group_SPI") %>%
mutate(region_pair = case_when(Direction == "Undirected" ~ ifelse(brain_region_1 < brain_region_2,
paste0(brain_region_1, "_", brain_region_2),
paste0(brain_region_2, "_", brain_region_1)),
Direction == "Directed" ~ paste0(brain_region_1, "_", brain_region_2))) %>%
dplyr::select(-brain_region_1, -brain_region_2)  %>%
distinct(Sample_ID, SPI, region_pair, .keep_all = T)
for (group_var in unique(grouping_var_vector)) {
if (grouping_var == "Combo") {
data_for_SVM <- pairwise_data %>%
# Impute missing data with the mean
group_by(Diagnosis, Combo) %>%
mutate(value = ifelse(is.na(value), mean(value, na.rm=T), value)) %>%
dplyr::select(Sample_ID, Diagnosis, Combo, value) %>%
tidyr::pivot_wider(id_cols = c(Sample_ID, Diagnosis),
names_from = Combo,
values_from
= value) %>%
# Drop columns that are all NA/NAN
dplyr::select(where(function(x) any(!is.na(x)))) %>%
# Drop rows with NA for one or more column
drop_na()
} else {
# Otherwise iterate over each separate group
data_for_SVM <- subset(pairwise_data, get(grouping_var_name) == group_var) %>%
dplyr::ungroup() %>%
dplyr::select(Sample_ID, Diagnosis, svm_feature_var_name, value) %>%
tidyr::pivot_wider(id_cols = c(Sample_ID, Diagnosis),
names_from = svm_feature_var_name,
values_from
= value) %>%
# Drop columns that are all NA/NAN
dplyr::select(where(function(x) any(!is.na(x)))) %>%
# Drop rows with NA for one or more column
drop_na()
}
if (nrow(data_for_SVM) > 0) {
# Run k-fold linear SVM
SVM_results <- k_fold_CV_linear_SVM(input_data = data_for_SVM,
flds = flds,
k = num_k_folds,
svm_kernel = svm_kernel,
sample_wts = sample_wts,
shuffle_labels = shuffle_labels,
out_of_sample_only = out_of_sample_only) %>%
dplyr::mutate(grouping_var = group_var,
pairwise_feature_set = pairwise_feature_set,
use_inv_prob_weighting = use_inv_prob_weighting,
Noise_Proc = noise_proc)
# Append results to list
class_res_list <- list.append(class_res_list, SVM_results)
} else {
cat("\nNo observations available for", group_var, "after filtering.\n")
}
}
# Combine results from all regions into a dataframe
class_res_df <- do.call(plyr::rbind.fill, class_res_list)
group_wise_SVM_CV_weighting <- class_res_df
saveRDS(group_wise_SVM_CV_weighting, file=paste0(rdata_path,
sprintf("%s_pairwise_CV_linear_SVM_%s_%s.Rds",
grouping_var,
pairwise_feature_set,
weighting_name)))
tryCatch({group_wise_SVM_CV_weighting <- run_pairwise_cv_svm_by_input_var(pairwise_data = pyspi_data,
data_path = data_path,
SPI_directionality = SPI_directionality,
svm_kernel = "linear",
num_k_folds = 10,
flds = sample_folds,
grouping_var = grouping_var,
svm_feature_var = SVM_feature_var,
noise_proc = noise_proc_for_null,
out_of_sample_only = TRUE,
use_inv_prob_weighting = use_inv_prob_weighting,
shuffle_labels = FALSE)
# saveRDS(group_wise_SVM_CV_weighting, file=paste0(rdata_path,
#                                                  sprintf("%s_pairwise_CV_linear_SVM_%s_%s.Rds",
#                                                          grouping_var,
#                                                          pairwise_feature_set,
#                                                          weighting_name)))
}, error = function(e) {
cat("Could not run linear SVM for", grouping_var, pairwise_feature_set, ".\n")
message(e)
})
group_wise_SVM_balanced_accuracy <- group_wise_SVM_CV_weighting %>%
group_by(grouping_var, Noise_Proc, Sample_Type) %>%
summarise(accuracy = sum(Prediction_Correct) / n(),
balanced_accuracy = caret::confusionMatrix(data = Predicted_Diagnosis,
reference = Actual_Diagnosis)$byClass[["Balanced Accuracy"]])
saveRDS(group_wise_SVM_balanced_accuracy, file=paste0(rdata_path, sprintf("%s_pairwise_CV_linear_SVM_%s_%s_balacc.Rds",
grouping_var,
pairwise_feature_set,
weighting_name)))
View(group_wise_SVM_balanced_accuracy)
