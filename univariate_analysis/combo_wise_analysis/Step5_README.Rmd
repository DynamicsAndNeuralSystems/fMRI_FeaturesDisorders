---
title: "Step 5: ROI+Feature Classification Analysis"
output: 
  github_document
always_allow_html: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, warning=F, message=F)
```

### Source functions
```{r}
source("../helper_functions/Linear_SVM.R")
source("../helper_functions/Visualization.R")
source("../helper_functions/Null_distributions.R")
rdata_path <- "D:/Virtual_Machines/Shared_Folder/PhD_work/data/scz/UCLA/Rdata/"
set.seed(127)
```

## Cross-validated SVM classification

### 10-fold cross-validated linear SVM

We can implement 10-fold cross-validation (CV) with the `caret` package.

```{r}
# Noise processing methods
noise_procs <- c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")

# Use e1071 SVM with a linear kernel
test_package = "e1071"
kernel = "linear"
  
# Run in-sample SVM using given package + kernel
# If the RDS object doesn't already exist, otherwise load it in
if (!file.exists(paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071.Rds"))) {
  combo_wise_SVM_CV <- run_cv_svm_by_input_var(rdata_path = rdata_path,
                                               svm_kernel = kernel,
                                               test_package = test_package,
                                               svm_feature_var = "Combo",
                                               grouping_var = "Combo",
                                               noise_procs = noise_procs,
                                               use_inv_prob_weighting = FALSE,
                                               use_SMOTE = FALSE)
  saveRDS(combo_wise_SVM_CV, file=paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071.Rds"))
}
```

```{r, fig.width=7, fig.height=5}
# Plot accuracy + balanced accuracy in histograms
# Control subject proportion is highlighted for accuracy
noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")
combo_wise_SVM_CV <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071.Rds"))

plot_class_acc_w_props(class_res = combo_wise_SVM_CV,
                       plot_title = "Unweighted Combo-wise\nLinear SVM Results",
                       rdata_path = rdata_path,
                       noise_procs = noise_procs,
                       ylab = "Value across 10 Folds")

# Save plot
ggsave("plots/Combo_Wise_Linear_SVM_CV_e1071.png",
       width=7, height=5, units="in", dpi=300)
```

As with in-sample SVM, the unweighted input samples are virtually all classified as control subjects across all 82 ROIs using the 10-fold cross-validation linear SVM with caret.

### 10-fold cross-validated linear SVM with inverse probability weighting

```{r}
# Try three different noise processing methods
noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")

# Use e1071 SVM with a linear kernel
test_package = "e1071"
kernel = "linear"
  
# Run theft's multivariable classifier on each ROI and save to an RDS object
# If the RDS object doesn't already exist, otherwise load it in
if (!file.exists(paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071_inv_prob.Rds"))) {
  
  combo_wise_SVM_CV_inv_prob <- run_cv_svm_by_input_var(rdata_path = rdata_path,
                                                        svm_kernel = kernel,
                                                        test_package = test_package,
                                                        svm_feature_var = "Combo",
                                                        grouping_var = "Combo",
                                                        noise_procs = noise_procs,
                                                        use_inv_prob_weighting = TRUE,
                                                        use_SMOTE = FALSE)
  
  saveRDS(combo_wise_SVM_CV_inv_prob, file=paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071_inv_prob.Rds"))
} 
```

```{r, fig.width=7, fig.height=5}
noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")
combo_wise_SVM_CV_inv_prob <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071_inv_prob.Rds"))

plot_class_acc_w_props(class_res = combo_wise_SVM_CV_inv_prob,
                       plot_title = "Inv Prob Weighted Combo-wise\nLinear SVM Results",
                       rdata_path = rdata_path,
                       noise_procs = noise_procs,
                       ylab = "Value across 10 Folds")

# Save plot
ggsave("plots/Combo_Wise_Linear_SVM_CV_e1071_inv_prob.png",
       width=7, height=5, units="in", dpi=300)
```


Surprisingly, incorporating inverse probability weighting has minimal impact when it comes to the ten-fold cross-validated SVM. Of note, the in-sample and cross-validated SVM were both run with kernlab::ksvm using default parameters.


### 10-fold cross-validated linear SVM with SMOTE

```{r}
# Try three different noise processing methods
noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")

# Use e1071 SVM with a linear kernel
test_package = "e1071"
kernel = "linear"

# Run theft's multivariable classifier on each ROI and save to an RDS object
# If the RDS object doesn't already exist, otherwise load it in
if (!file.exists(paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071_SMOTE.Rds"))) {
  
  combo_wise_SVM_CV_SMOTE <- run_cv_svm_by_input_var(rdata_path = rdata_path,
                                                     svm_kernel = kernel,
                                                     test_package = test_package,
                                                     svm_feature_var = "Combo",
                                                     grouping_var = "Combo",
                                                     noise_procs = noise_procs,
                                                     use_inv_prob_weighting = FALSE,
                                                     use_SMOTE = TRUE)
  
  saveRDS(combo_wise_SVM_CV_SMOTE, file=paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071_SMOTE.Rds"))
} 
```

```{r, fig.width=7, fig.height=5}
noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")
combo_wise_SVM_CV_SMOTE <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071_SMOTE.Rds"))

plot_class_acc_w_props(class_res = combo_wise_SVM_CV_SMOTE,
                       plot_title = "SMOTE Weighted Combo-wise\nLinear SVM Results",
                       rdata_path = rdata_path,
                       noise_procs = noise_procs,
                       ylab = "Value across 10 Folds")

# Save plot
ggsave("plots/Combo_Wise_Linear_SVM_CV_e1071_SMOTE.png",
       width=7, height=5, units="in", dpi=300)
```


Surprisingly, incorporating inverse probability weighting has minimal impact when it comes to the ten-fold cross-validated SVM. Of note, the in-sample and cross-validated SVM were both run with kernlab::ksvm using default parameters.


## Model-free shuffle null distribution

### Generating null distributions from model-free shuffles

This first model-free shuffles method is borrowed from Trent's implementation in theft. With this method, the input class labels (Schz or Control) are randomly shuffled N times, and for each iteration, the classification accuracy and balanced accuracy are calculated. This yields a null distribution of accuracies and balanced accuracies, circumventing the need for running any classification algorithms across iterations.

Here, I've run 1,000,000 iterations of the model-free shuffle, generating 1,000,000 null values for Accuracy and Balanced Accuracy, respectively. Since this method is independent of ROI/feature combo, the same null distribution can be used to compare with each ROI/feature combo separately.

```{r}
# Try three different noise processing methods
noise_procs = c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")

# One without minority upsampling
if (!file.exists(paste0(rdata_path, "Null_Model_Free_Shuffles.Rds"))) {
  set.seed(127) 
  model_free_shuffle_null_res <- run_model_free_n_shuffles(num_shuffles = 1000000,
                                                    rdata_path = rdata_path,
                                                    noise_procs = noise_procs)
  saveRDS(model_free_shuffle_null_res, file = paste0(rdata_path, "Null_Model_Free_Shuffles.Rds"))
} else {
  model_free_shuffle_null_res <- readRDS(paste0(rdata_path, "Null_Model_Free_Shuffles.Rds"))
}
```


### CV linear SVM

```{r}
# Calculate p values from model-free shuffle null distribution
if (!file.exists(paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071_pvals.Rds"))) {
  combo_wise_SVM_CV_pvals <- calc_empirical_nulls(class_res = combo_wise_SVM_CV,
                                                   null_data = model_free_shuffle_null_res,
                                                   grouping_var = "Combo")
  saveRDS(combo_wise_SVM_CV_pvals, file=paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071_pvals.Rds"))
} else {
  combo_wise_SVM_CV_pvals <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071_pvals.Rds"))
}

combo_wise_SVM_CV_plabs <- truncate_p_values(combo_wise_SVM_CV_pvals, N=3)
```
I've plotted the distribution of null accuracies (gray) alongside the actual accuracies (green, red, and blue) for the ROI/Feature combos per noise-processing method.

```{r, fig.width=7, fig.height=5}
plot_top_6_vars_main_vs_null(class_res_pvals = combo_wise_SVM_CV_pvals,
                             null_res = model_free_shuffle_null_res,
                             sample_type = "Out-of-sample",
                             xlab = "Value",
                             ylab = "Scaled Density of Null Iterations",
                             title = "Main Out-of-Sample and Model-Free Shuffle Null Balanced Accuracy\nfor top AROMA+2P ROI/Feature Combos",
                             combo=T)

ggsave("plots/Combo_Wise_Model_Free_Shuffle_Top5_Regions_CV_SVM_Balanced_Accuracy.png", width=7, 
       height=5, units="in", dpi=300)
```

```{r}
combo_wise_SVM_CV_pvals_out <- subset(combo_wise_SVM_CV_pvals, Sample_Type=="Out-of-sample")
color.me <- which(combo_wise_SVM_CV_pvals_out$bal_acc_p < 0.05)

combo_wise_SVM_CV_pvals_out %>%
  mutate(Noise_Proc = factor(Noise_Proc, levels = noise_procs)) %>%
  arrange(Noise_Proc) %>%
  dplyr::select(Noise_Proc, balanced_accuracy, bal_acc_p) %>%
  kable(.) %>%
  kable_styling(full_width = F) %>%
  row_spec(color.me, bold = T, color = "black", background = "palegreen")
```

This table summarises the number of ROIs for which raw accuracy or balanced accuracy is significantly greater than the model-free shuffle null distribution, both before and after adjusting for multiple comparisons with BH-FDR.


### CV linear SVM -- inv prob


```{r}
# Calculate p values from model-free shuffle null distribution
combo_wise_SVM_CV_inv_prob <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071_inv_prob.Rds"))
if (!file.exists(paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071_inv_prob_pvals.Rds"))) {
  combo_wise_SVM_CV_inv_prob_pvals <- calc_empirical_nulls(class_res = combo_wise_SVM_CV_inv_prob,
                                                   null_data = model_free_shuffle_null_res,
                                                   grouping_var = "Combo")
  saveRDS(combo_wise_SVM_CV_inv_prob_pvals, file=paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071_inv_prob_pvals.Rds"))
} else {
  combo_wise_SVM_CV_inv_prob_pvals <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071_inv_prob_pvals.Rds"))
}


combo_wise_SVM_CV_inv_prob_plabs <- truncate_p_values(combo_wise_SVM_CV_inv_prob_pvals)
```


```{r, fig.width=7, fig.height=5}
plot_top_6_vars_main_vs_null(class_res_pvals = combo_wise_SVM_CV_inv_prob_pvals,
                             null_res = model_free_shuffle_null_res,
                             sample_type = "Out-of-sample",
                             xlab = "Value",
                             ylab = "Scaled Density of Null Iterations",
                             title = "Main Out-of-Sample and Model-Free Shuffle Null Balanced Accuracy\nfor top AROMA+2P ROI/Feature Combos, Inverse Probability",
                             combo = TRUE)

# Save plot
ggsave("plots/Combo_Wise_Model_Free_Shuffle_Top5_Regions_CV_SVM_Balanced_Accuracy_Inv_Prob.png", width=7, 
       height=5, units="in", dpi=300)
```

I've plotted the distribution of null accuracies (gray) alongside the actual accuracies (green, red, and blue) for the ROI/Feature combos per noise-processing method.

```{r}
combo_wise_SVM_CV_inv_prob_pvals_out <- subset(combo_wise_SVM_CV_inv_prob_pvals, Sample_Type=="Out-of-sample")
color.me <- which(combo_wise_SVM_CV_inv_prob_pvals_out$bal_acc_p < 0.05)

combo_wise_SVM_CV_inv_prob_pvals_out %>%
  mutate(Noise_Proc = factor(Noise_Proc, levels = noise_procs)) %>%
  arrange(Noise_Proc) %>%
  dplyr::select(Noise_Proc, balanced_accuracy, bal_acc_p) %>%
  kable(.) %>%
  kable_styling(full_width = F) %>%
  row_spec(color.me, bold = T, color = "black", background = "palegreen")
```

This table summarises the number of ROIs for which raw accuracy or balanced accuracy is significantly greater than the model-free shuffle null distribution, both before and after adjusting for multiple comparisons with BH-FDR.

### CV linear SVM -- SMOTE

```{r}
# Calculate p values from model-free shuffle null distribution
combo_wise_SVM_CV_SMOTE <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071_SMOTE.Rds"))
if (!file.exists(paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071_SMOTE_pvals.Rds"))) {
  combo_wise_SVM_CV_SMOTE_pvals <- calc_empirical_nulls(class_res = combo_wise_SVM_CV_SMOTE,
                                                   null_data = model_free_shuffle_null_res,
                                                   grouping_var = "Combo")
  saveRDS(combo_wise_SVM_CV_SMOTE_pvals, file=paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071_SMOTE_pvals.Rds"))
} else {
  combo_wise_SVM_CV_SMOTE_pvals <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071_SMOTE_pvals.Rds"))
}


combo_wise_SVM_CV_SMOTE_plabs <- truncate_p_values(combo_wise_SVM_CV_SMOTE_pvals)
```

```{r, fig.width=7, fig.height=5}
plot_top_6_vars_main_vs_null(class_res_pvals = combo_wise_SVM_CV_SMOTE_pvals,
                             null_res = model_free_shuffle_null_res,
                             sample_type = "Out-of-sample",
                             xlab = "Value",
                             ylab = "Scaled Density of Null Iterations",
                             title = "Main Out-of-Sample and Model-Free Shuffle Null Balanced Accuracy\nfor top AROMA+2P ROI/Feature Combos, SMOTE",
                             combo = TRUE)

# Save plot
ggsave("plots/Combo_Wise_Model_Free_Shuffle_Top5_Regions_CV_SVM_Balanced_Accuracy_SMOTE.png", width=7, 
       height=5, units="in", dpi=300)
```


I've plotted the distribution of null accuracies (gray) alongside the actual accuracies (green, red, and blue) for the ROI/Feature combos per noise-processing method.

```{r}
combo_wise_SVM_CV_SMOTE_pvals_out <- subset(combo_wise_SVM_CV_SMOTE_pvals, Sample_Type=="Out-of-sample")
color.me <- which(combo_wise_SVM_CV_SMOTE_pvals_out$bal_acc_p < 0.05)

combo_wise_SVM_CV_SMOTE_pvals_out %>%
  mutate(Noise_Proc = factor(Noise_Proc, levels = noise_procs)) %>%
  arrange(Noise_Proc) %>%
  dplyr::select(Noise_Proc, balanced_accuracy, bal_acc_p) %>%
  kable(.) %>%
  kable_styling(full_width = F) %>%
  row_spec(color.me, bold = T, color = "black", background = "palegreen")
```

This table summarises the number of ROIs for which raw accuracy or balanced accuracy is significantly greater than the model-free shuffle null distribution, both before and after adjusting for multiple comparisons with BH-FDR.

## Empirical model-based pooled null distribution

### Generating null distributions from pooled null model fits

In contrast to the model-free shuffle method, here we are actually shuffling the input class labels right before running the linear SVM over N=100 iterations per ROI (N=82) and pooling the resulting accuracy and balanced accuracy values, to generate empirical null distributions of N=1,000 data points each, respectively.

### Unweighted

```{r}
# Run null model permutation function
noise_procs <- c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")
set.seed(127)

if (!file.exists(paste0(rdata_path, "Combo_wise_model_permutation_null_unweighted.Rds"))) {
  model_permutation_null_unweighted <- run_null_model_n_permutations(rdata_path,
                                                                    noise_procs = noise_procs,
                                                                    grouping_var = "Combo",
                                                                    svm_feature_var = "Combo",
                                                                    num_permutations = 100,
                                                                    use_inv_prob_weighting = FALSE,
                                                                    use_SMOTE = FALSE)
  
  saveRDS(model_permutation_null_unweighted, file=paste0(rdata_path, "Combo_wise_model_permutation_null_unweighted.Rds"))
} else {
  model_permutation_null_unweighted <- readRDS(paste0(rdata_path, "Combo_wise_model_permutation_null_unweighted.Rds"))
}
# Find number of iterations for plot label
num_null_dist_values <- nrow(model_permutation_null_unweighted %>% filter(Noise_Proc == "AROMA+2P"))
```


### CV, inverse probability weighted

```{r}
# Run null model permutation function
noise_procs <- c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")
svm_kernel <- "linear"
set.seed(127)

if (!file.exists(paste0(rdata_path, "Combo_wise_model_permutation_null_CV_inv_prob.Rds"))) {
  model_permutation_null_CV_inv_prob <- run_null_model_n_permutations(rdata_path,
                                                                    noise_procs = noise_procs,
                                                                    grouping_var = "Combo",
                                                                    svm_feature_var = "Combo",
                                                                    num_permutations = 100,
                                                                    use_inv_prob_weighting = TRUE,
                                                                    use_SMOTE = FALSE)
  
  saveRDS(model_permutation_null_CV_inv_prob, file=paste0(rdata_path, "Combo_wise_model_permutation_null_CV_inv_prob.Rds"))
} else {
  model_permutation_null_CV_inv_prob <- readRDS(paste0(rdata_path, "Combo_wise_model_permutation_null_CV_inv_prob.Rds"))
}
```


```{r}
combo_wise_SVM_CV_inv_prob <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071_inv_prob.Rds"))

if (!file.exists(paste0(rdata_path, "Combo_wise_CV_Null_Model_Fits_pvals_inv_prob.Rds"))) {
  combo_wise_SVM_CV_inv_prob_pvals <- calc_empirical_nulls(class_res = combo_wise_SVM_CV_inv_prob,
                                                              null_data = model_permutation_null_CV_inv_prob,
                                                              grouping_var = "Combo")
  saveRDS(combo_wise_SVM_CV_inv_prob_pvals, file=paste0(rdata_path, "Combo_wise_CV_Null_Model_Fits_pvals_inv_prob.Rds"))
} else {
  combo_wise_SVM_CV_inv_prob_pvals <- readRDS(paste0(rdata_path, "Combo_wise_CV_Null_Model_Fits_pvals_inv_prob.Rds"))
}

combo_wise_SVM_CV_inv_prob_plabs <- truncate_p_values(combo_wise_SVM_CV_inv_prob_pvals)
```

```{r, fig.width=7, fig.height=5}
plot_top_6_vars_main_vs_null(class_res_pvals = combo_wise_SVM_CV_inv_prob_pvals,
                             null_res = model_permutation_null_CV_inv_prob,
                             xlab = "Value",
                             ylab = "Scaled Density of Null Iterations",
                             title = "Main and Null Model Fit Balanced Accuracy\nfor top AROMA+2P ROI/Feature Combos, CV Inv Prob",
                             combo = TRUE)

# Save plot
ggsave("plots/Combo_Wise_Null_Model_Fit_CV_Inv_Prob_Balanced_Accuracy.png", width=7, 
       height=5, units="in", dpi=300)
```

The fitted empirical null model distribution is fairly similar to the real accuracy and balanced accuracy values using in-sample linear SVM with no reweighting. 

```{r}
color.me <- which(combo_wise_SVM_CV_inv_prob_pvals$bal_acc_p < 0.05)

combo_wise_SVM_CV_inv_prob_plabs %>%
  mutate(Noise_Proc = factor(Noise_Proc, levels = noise_procs)) %>%
  arrange(Noise_Proc) %>%
  dplyr::select(Noise_Proc, balanced_accuracy, bal_acc_p) %>%
  kable(.) %>%
  kable_styling(full_width = F) %>%
  row_spec(color.me, bold = T, color = "black", background = "palegreen")
```


### CV, SMOTE

```{r}
# Run null model permutation function
noise_procs <- c("AROMA+2P", "AROMA+2P+GMR", "AROMA+2P+DiCER")
svm_kernel <- "linear"
set.seed(127)

if (!file.exists(paste0(rdata_path, "Combo_wise_model_permutation_null_CV_SMOTE.Rds"))) {
  model_permutation_null_CV_SMOTE <- run_null_model_n_permutations(rdata_path,
                                                                    noise_procs = noise_procs,
                                                                    grouping_var = "Combo",
                                                                    svm_feature_var = "Combo",
                                                                    num_permutations = 100,
                                                                    use_inv_prob_weighting = FALSE,
                                                                    use_SMOTE = TRUE)
  
  saveRDS(model_permutation_null_CV_SMOTE, file=paste0(rdata_path, "Combo_wise_model_permutation_null_CV_SMOTE.Rds"))
} else {
  model_permutation_null_CV_SMOTE <- readRDS(paste0(rdata_path, "Combo_wise_model_permutation_null_CV_SMOTE.Rds"))
}
```

```{r}
combo_wise_SVM_CV_SMOTE <- readRDS(paste0(rdata_path, "Combo_wise_linear_SVM_CV_e1071_SMOTE.Rds"))

if (!file.exists(paste0(rdata_path, "Combo_wise_CV_Null_Model_Fits_pvals_SMOTE.Rds"))) {
  combo_wise_SVM_CV_SMOTE_pvals <- calc_empirical_nulls(class_res = combo_wise_SVM_CV_SMOTE,
                                                              null_data = model_permutation_null_CV_SMOTE,
                                                              grouping_var = "Combo")
  saveRDS(combo_wise_SVM_CV_SMOTE_pvals, file=paste0(rdata_path, "Combo_wise_CV_Null_Model_Fits_pvals_SMOTE.Rds"))
} else {
  combo_wise_SVM_CV_SMOTE_pvals <- readRDS(paste0(rdata_path, "Combo_wise_CV_Null_Model_Fits_pvals_SMOTE.Rds"))
}

combo_wise_SVM_CV_SMOTE_plabs <- truncate_p_values(combo_wise_SVM_CV_SMOTE_pvals)
```

```{r, fig.width=7, fig.height=5}
plot_top_6_vars_main_vs_null(class_res_pvals = combo_wise_SVM_CV_SMOTE_pvals,
                             null_res = model_permutation_null_CV_SMOTE,
                             xlab = "Value",
                             ylab = "Scaled Density of Null Iterations",
                             title = "Main and Null Model Fit Balanced Accuracy\nfor top AROMA+2P ROI/Feature Combos, CV SMOTE",
                             combo = TRUE)

# Save plot
ggsave("plots/Combo_Wise_Null_Model_Fit_Top5_Regions_CV_SMOTE_Balanced_Accuracy.png", width=7, 
       height=5, units="in", dpi=300)
```

The fitted empirical null model distribution is fairly similar to the real accuracy and balanced accuracy values using in-sample linear SVM with no reweighting. 

```{r}
color.me <- which(combo_wise_SVM_CV_SMOTE_pvals$bal_acc_p < 0.05)

combo_wise_SVM_CV_SMOTE_plabs %>%
  mutate(Noise_Proc = factor(Noise_Proc, levels = noise_procs)) %>%
  arrange(Noise_Proc) %>%
  dplyr::select(Noise_Proc, balanced_accuracy, bal_acc_p) %>%
  kable(.) %>%
  kable_styling(full_width = F) %>%
  row_spec(color.me, bold = T, color = "black", background = "palegreen")
```


## Comparing model-free shuffle with pooled empirical null distributions

```{r, fig.width = 7, fig.height = 7}
# In-sample inverse probability
in_sample_inv_prob_p <- model_free_shuffle_null_res %>%
  mutate(Null_Type = "Model-Free Shuffle") %>%
  plyr::rbind.fill(model_permutation_null_CV_inv_prob %>% 
                     filter(Sample_Type == "In-sample") %>%
                     mutate(Null_Type = "Null Model Fit, In-sample Inv Prob")) %>%
  mutate(Null_Type = factor(Null_Type, levels = c("Model-Free Shuffle",
                                                  "Null Model Fit, In-sample Inv Prob",
                                                  "Null Model Fit, Out-of-sample Inv Prob",
                                                  "Null Model Fit, Out-of-sample SMOTE"))) %>%
  ggplot(data=., mapping=aes(x=balanced_accuracy, fill=Null_Type)) +
  geom_histogram(alpha=0.5, 
                 aes(y=0.5*..density..), 
                 position="identity",
                 bins = 50) +
  scale_x_continuous(limits = c(0.3, 1.01)) +
  ylab("") +
  xlab("") +
  labs(fill = "Null Type") +
  scale_fill_manual(values = list("Model-Free Shuffle" = "gray70", 
                                  "Null Model Fit, In-sample Inv Prob" = "coral",
                                  "Null Model Fit, Out-of-sample Inv Prob" = "dodgerblue",
                                  "Null Model Fit, Out-of-sample SMOTE" = "green"))

# Out-of-sample inverse probability
CV_inv_prob_p <- model_free_shuffle_null_res %>%
  mutate(Null_Type = "Model-Free Shuffle") %>%
  plyr::rbind.fill(model_permutation_null_CV_inv_prob %>% 
                     filter(Sample_Type == "Out-of-sample") %>%
                     mutate(Null_Type = "Null Model Fit, Out-of-sample Inv Prob")) %>%
  mutate(Null_Type = factor(Null_Type, levels = c("Model-Free Shuffle",
                                                  "Null Model Fit, In-sample Inv Prob",
                                                  "Null Model Fit, Out-of-sample Inv Prob",
                                                  "Null Model Fit, Out-of-sample SMOTE"))) %>%
  ggplot(data=., mapping=aes(x=balanced_accuracy, fill=Null_Type)) +
  geom_histogram(alpha=0.5, 
                 aes(y=0.5*..density..), 
                 position="identity",
                 bins = 50) +
  scale_x_continuous(limits = c(0.3, 1.01)) +
  ylab("Scaled Density") +
  xlab("") +
  labs(fill = "Null Type") +
  scale_fill_manual(values = list("Model-Free Shuffle" = "gray70", 
                                  "Null Model Fit, In-sample Inv Prob" = "coral",
                                  "Null Model Fit, Out-of-sample Inv Prob" = "dodgerblue",
                                  "Null Model Fit, Out-of-sample SMOTE" = "green"))

# Out-of-sample SMOTE
CV_SMOTE_p <- model_free_shuffle_null_res %>%
  mutate(Null_Type = "Model-Free Shuffle") %>%
  plyr::rbind.fill(model_permutation_null_CV_SMOTE %>% 
                     filter(Sample_Type == "Out-of-sample") %>%
                     mutate(Null_Type = "Null Model Fit, Out-of-sample SMOTE")) %>%
  mutate(Null_Type = factor(Null_Type, levels = c("Model-Free Shuffle",
                                                  "Null Model Fit, In-sample Inv Prob",
                                                  "Null Model Fit, Out-of-sample Inv Prob",
                                                  "Null Model Fit, Out-of-sample SMOTE"))) %>%
  ggplot(data=., mapping=aes(x=balanced_accuracy, fill=Null_Type)) +
  geom_histogram(alpha=0.5, 
                 aes(y=0.5*..density..), 
                 position="identity",
                 bins = 50) +
  scale_x_continuous(limits = c(0.3, 1.01)) +
  ylab("") +
  xlab("Balanced Accuracy") +
  labs(fill = "Null Type") +
  scale_fill_manual(values = list("Model-Free Shuffle" = "gray70", 
                                  "Null Model Fit, In-sample Inv Prob" = "coral",
                                  "Null Model Fit, Out-of-sample Inv Prob" = "dodgerblue",
                                  "Null Model Fit, Out-of-sample SMOTE" = "green"))

in_sample_inv_prob_p / CV_inv_prob_p / CV_SMOTE_p  + 
  plot_annotation(title = "Null Distributions by Model Type") + 
  plot_layout(guides = "collect") & 
  theme(legend.position = 'bottom') &
  guides(fill = guide_legend(nrow=2,byrow=TRUE))
ggsave("plots/Null_Distributions_by_Model_Type.png",
       width = 7, height = 7, units = "in", dpi=300)
```

 